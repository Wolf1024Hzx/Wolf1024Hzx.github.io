---
title: 面试官给您跪下了qaq
tags: 前端
categories: 学习
date: 2023-04-05 23:12:14
---


# Promise

## 手写 Promise.all

```JavaScript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const result = []
    // 已完成的promise个数
    let count = 0
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        count++
        result[index] = value
        // 全部完成才resolve
        if (count === promises.length)
          resolve(result)
      }, reason => {
        // 有一个失败就返回reject
        reject(reason)
      })
    })
  })
}
```

## 手写 Prmise.race

```JavaScript
function promiseRace(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach((promise) => {
      // 根据第一个完成的结果决定返回类型
      Promise.resolve(promise).then(resolve, reject)
    })
  })
}
```

# 防抖和节流

## 防抖

防抖的作用是，事件触发后隔一段时间才执行；如果期间再次触发，重置计时器。也就是说，如果事件触发频率过高，只有最后一次生效（只生效一次）

```JavaScript
// 防抖
function debounce(fn, time) {
  let timeout = null // 创建一个标记用来存放定时器的返回值
  return function () {
    const args = arguments
    clearTimeout(timeout) // 每当用户输入的时候把前一个 setTimeout clear 掉
    timeout = setTimeout(() => {
      // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
      fn.apply(this, args)
    }, time)
  }
}
```

## 节流

节流的作用是，事件触发后隔一段时间才执行，等待期间再次触发事件均不执行回调，直到等待时间结束，本次事件执行完毕，才可以触发这个事件。

```JavaScript
// 节流
function throttle(fn, time) {
  let canRun = true // 通过闭包保存一个标记
  return function () {
    if (!canRun) return // 在函数开头判断标记是否为true，不为true则return
    canRun = false // 立即设置为false
    const args = arguments
    const timer = time ? setTimeout : requestAnimationFrame
    timer(() => {
      // 将外部传入的函数的执行放在setTimeout中
      fn.apply(this, args)
      // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
      canRun = true
    }, time)
  }
}
```

第二种写法，通过时间戳判断是否可以触发事件

```JavaScript
// 节流
function throttle(fn, time) {
  let front = 0 // 通过闭包保存一个标记
  return function () {
    const now = new Date()
    if (now - front <= time) return // 上一次未结束
    front = now
    const args = arguments
    const timer = time ? setTimeout : requestAnimationFrame
    timer(() => {
      fn.apply(this, args)
    }, time)
  }
}
```

## 应用场景

举个栗子，百度的搜索框，输入事件触发后调用搜索接口，但肯定不希望接口调用过快。首先我们希望保证每输入一个字都搜索一次的效果（输入较慢的情况下），因此还是得用节流。但我们由希望结果由最后一次输入决定，因此节流的内部又需要使用防抖，因此用如下代码实现：

```JavaScript
function both(fn, time) {
  let timeout = null
  let front = 0
  return function() {
    const args = arguments
    const now = new Date()
    // 先节流
    if (now - front > time) {
      clearTimeout(timeout)
      front = now
      fn.apply(this, args)
    } else {
      // 内部使用防抖
      clearTimeout(timeout)
      timeout = setTimeout(() => {
        fn.apply(this, args)
      })
    }
  }
}
```
