<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Uniapp打包安卓apk流程记录</title>
    <link href="/2024/09/07/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/09/07/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="云打包"><a href="#云打包" class="headerlink" title="云打包"></a>云打包</h1><p>访问 <a href="https://ask.dcloud.net.cn/account/setting/profile/">DCloud 官网个人主页</a> 绑定手机号完成验证</p><p>在 HBuilder 中打开项目的 manifest.json ，填写 AppID （没有则点重新获取，同一项目仅获取一次）</p><p>点击“发行”-&gt;“原生App-云打包”</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E4%BA%91%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20112256.png" alt="云打包截图"></p><p>等待即可（期间可能会自动下载所需插件，如 scss 和 less 的编译插件等）</p><p>打包完成后即可点击链接下载 apk</p><h1 id="本地打包"><a href="#本地打包" class="headerlink" title="本地打包"></a>本地打包</h1><h2 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h2><p>首先装 Java 环境， JDK 版本不建议过低，亲测 21.0.4 的 LTS 可以用</p><p>安装 android studio 的旧版本（新版本似乎仅支持 Kotlin ），可以在 <a href="https://developer.android.google.cn/studio/archive">AS 旧版本列表</a> 中下载旧版本</p><p>推荐 4.2.2 ，<a href="https://redirector.gvt1.com/edgedl/android/studio/install/4.2.2.0/android-studio-ide-202.7486908-windows.exe">下载链接</a></p><h2 id="uniapp-官方-SDK"><a href="#uniapp-官方-SDK" class="headerlink" title="uniapp 官方 SDK"></a>uniapp 官方 SDK</h2><p><a href="https://nativesupport.dcloud.net.cn/AppDocs/download/android.html">官方 SDK 下载链接</a></p><p>下载后打开目录，结构如下图所示：</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20113926.png" alt="uniapp sdk 目录结构"></p><p>仅需用到 HBuilder-Integrate-AS</p><p>使用 android studio 打开 HBuilder-Integrate-AS 项目</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20114233.png" alt="HBuilder-Integrate-AS"></p><p>左上角把视图改为 Project</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20114347.png" alt="项目视图"></p><p>配置 Project Structure 为项目指定 JDK 和 SDK version</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20114702.png" alt="Project Structure 1"></p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20114751.png" alt="Project Structure 2"></p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20115000.png" alt="Project Structure 3"></p><h2 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h2><p>打开 HBuilder ，将 uniapp 项目生成本地打包资源</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20115304.png" alt="生成本地打包资源"></p><p>将生成的 __UNI__APPID 目录移入 HBuilder-Integrate-AS 项目中对应的位置上</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20115523.png" alt="插入 uniapp 打包资源"></p><p>替换 dcloud_control.xml 中的 AppId （没改动则不需要替换）</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20115747.png" alt="替换 AppId"></p><h2 id="获取-AppKey-和签名"><a href="#获取-AppKey-和签名" class="headerlink" title="获取 AppKey 和签名"></a>获取 AppKey 和签名</h2><p>在 AS 中生成应用签名</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20120221.png" alt="生成应用签名"></p><p>这一步会生成一个 keystore 文件，里面存储我们的签名</p><p>记住 keystore 的存储路径（最好设置在项目目录里）、 keystore 的密码、 key 的别名和 key password</p><p>在 cmd 中输入 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs BASH">keytool -list -v -keystore [keystore 存储路径]<br></code></pre></td></tr></table></figure><p>查看签名证书的 SHA1 和 SHA256指纹</p><p>会输出类似下列结构的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs BASH">Keystore <span class="hljs-built_in">type</span>: PKCS12    <br>Keystore provider: SUN    <br><br>Your keystore contains 1 entry    <br><br>Alias name: <span class="hljs-built_in">test</span>    <br>Creation <span class="hljs-built_in">date</span>: 2019-10-28    <br>Entry <span class="hljs-built_in">type</span>: PrivateKeyEntry    <br>Certificate chain length: 1    <br>Certificate[1]:    <br>Owner: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN    <br>Issuer: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN    <br>Serial number: 7dd12840    <br>Valid from: Fri Jul 26 20:52:56 CST 2019 until: Sun Jul 02 20:52:56 CST 2119    <br>Certificate fingerprints:    <br>         MD5:  F9:F6:C8:1F:DB:AB:50:14:7D:6F:2C:4F:CE:E6:0A:A5    <br>         SHA1: BB:AC:E2:2F:97:3B:18:02:E7:D6:69:A3:7A:28:EF:D2:3F:A3:68:E7    <br>         SHA256: 24:11:7D:E7:36:12:BC:FE:AF:2A:6A:24:BD:04:4F:2E:33:E5:2D:41:96:5F:50:4D:74:17:7F:4F:E2:55:EB:26    <br>Signature algorithm name: SHA256withRSA    <br>Subject Public Key Algorithm: 2048-bit RSA key    <br>Version: 3<br></code></pre></td></tr></table></figure><p><strong>MD5不一定有，据说看 JDK 和 SDK 版本，但不是必须</strong></p><p>登录 <a href="https://dev.dcloud.net.cn/pages/app/list">DCloud 开发者后台</a> 可以看到我们申请的 AppID 列表</p><p>进入我们需要打包的应用，选择“各平台信息”并添加，填入基本信息</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20121303.png" alt="各平台信息"></p><p>包名在 HBuilder-Integrate-AS 的 AndroidManifest.xml 中获取</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20121514.png" alt="包名获取"></p><p>填写完毕后，即可查看离线打包 key</p><p>修改 simpleDemo 中的 build.gradle 填入刚刚获得的签名证书信息</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20121805.png" alt="build.gradle"></p><p>最后修改 AndroidManifest.xml 中的 AppKey</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20122035.png" alt="AppKey"></p><p>已经可以打包成 apk 了</p><p><img src="/img/Uniapp%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-05%20122143.png" alt="生成 apk"></p><p>在 AS 弹出来的信息中点击 locate 即可打开 apk 文件所在目录</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小红书爬虫(JS注入和RPC爬虫)</title>
    <link href="/2024/02/20/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%88%AC%E8%99%AB/"/>
    <url>/2024/02/20/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前搜到能看到源码，能自己复现的小红书爬虫，基本都是已知笔记 id 和用户 id，爬取笔记详情和用户详情的。<br>这两种需求对应的接口分别是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET https://www.xiaohongshu.com/explore/[笔记id]<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GET https://www.xiaohongshu.com/user/profile/[用户id]<br></code></pre></td></tr></table></figure><p>这两个接口不需要认证因此非常简单。</p><p>而其他接口均需要以下三个请求头字段作为校验</p><p><img src="/img/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%88%AC%E8%99%AB/homefeed%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E5%A4%B4.jpg" alt="三个请求头"></p><p>经过长时间尝试后，实在是能力有限，无法通过补环境补出 X-s 的生成算法，故使用 JS 注入和 RPC 远程调用的方式，下面以两个案例展开</p><h1 id="JS-注入"><a href="#JS-注入" class="headerlink" title="JS 注入"></a>JS 注入</h1><p>假设现在的需求是在首页各个模块推荐的笔记中爬取出所有作者的 id</p><p>该接口为<code>POST https://edith.xiaohongshu.com/api/sns/web/v1/homefeed</code></p><p>JS 注入原理相当简单</p><p>我们虽然无法伪造出这个请求，但可以在前端进行 DOM 操作提取出显示在浏览器上的信息。先观察前端的页面结构：</p><p><img src="/img/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%88%AC%E8%99%AB/%E5%89%8D%E7%AB%AF%E7%BB%93%E6%9E%84.jpg" alt="前端结构"></p><p>可以发现笔记都在 id 为 exploreFeeds 的 div 下，存在一个个 section 里</p><p>而 section 中的结构又如下</p><p><img src="/img/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%88%AC%E8%99%AB/section%E8%AF%A6%E6%83%85.jpg" alt="section详情"></p><p>可以看到笔记的 id 和作者的 id，接下来我们使用 DOM 操作提取一下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-keyword">let</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;note-item&#x27;</span>) <span class="hljs-comment">// section的class都是这个</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> el <span class="hljs-keyword">of</span> elements) &#123;<br>    <span class="hljs-keyword">let</span> childrenElements = el.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">children</span><br>    <span class="hljs-keyword">let</span> noteId = <span class="hljs-title function_">getNoteId</span>(childrenElements[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">let</span> userId = <span class="hljs-title function_">getUserId</span>(childrenElements[<span class="hljs-number">2</span>])<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;提取出内容&#x27;</span>, noteId, userId)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入a标签获取笔记id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Element</span>&#125; <span class="hljs-variable">el</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 笔记id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNoteId</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">let</span> url = el.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>)<br>    <span class="hljs-keyword">var</span> match = url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\/explore\/(.*)/</span>)<br>    <span class="hljs-keyword">if</span> (match &amp;&amp; match[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> match[<span class="hljs-number">1</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入footer获取作者id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Element</span>&#125; <span class="hljs-variable">el</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 作者id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params">el</span>) &#123;<br>    el = el.<span class="hljs-property">children</span>[<span class="hljs-number">1</span>].<span class="hljs-property">children</span>[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> url = el.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>)<br>    <span class="hljs-keyword">let</span> match = url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\/user\/profile\/(.*)/</span>)<br>    <span class="hljs-keyword">if</span> (match &amp;&amp; match[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> match[<span class="hljs-number">1</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把这段代码放控制台运行一下试试</p><p><img src="/img/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%A6%96%E9%A1%B5%E7%88%AC%E8%99%AB/DOM%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%9C.jpg" alt="DOM操作结果"></p><p>那么接下来要干的事情有两件:</p><ul><li>把提取出的数据保存下来</li><li>让这段代码自动刷新页面爬取下一页数据</li></ul><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><p>对于第一个任务，众所周知浏览器的 js 脚本运行在一个封闭的沙箱环境中，无法直接操作本机上的文件，因此我们把提取出来的数据通过网络请求发送到本机的服务器程序上</p><p>js 中发送请求的部分如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-title function_">sendRequest</span>(&#123; userId, noteId &#125;)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendRequest</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://localhost:端口号/接口路径&#x27;</span><br>    <span class="hljs-title function_">fetch</span>(url, &#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>写一个简单的服务器程序接收并存入文件即可</p><h2 id="自动刷新爬取更多数据"><a href="#自动刷新爬取更多数据" class="headerlink" title="自动刷新爬取更多数据"></a>自动刷新爬取更多数据</h2><p>在js代码中添加一行<code>location.reload()</code>即可自动刷新，加入定时器即可反复执行</p><p>把代码封装成油猴脚本使用起来更加方便，最终脚本如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-comment">// ==UserScript==</span><br><span class="hljs-comment">// @name         小红书爬取工具</span><br><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><br><span class="hljs-comment">// @version      1.0.0</span><br><span class="hljs-comment">// @description  个人用</span><br><span class="hljs-comment">// @author       Wolf1024hzx</span><br><span class="hljs-comment">// @match     https://www.xiaohongshu.com/explore?channel_id=*</span><br><span class="hljs-comment">// @grant        none</span><br><span class="hljs-comment">// ==/UserScript==</span><br><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> timeoutHandler = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timeoutHandler)<br><br>        <span class="hljs-keyword">let</span> type = <span class="hljs-title function_">getType</span>()<br>        <span class="hljs-keyword">let</span> elements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;note-item&#x27;</span>)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> el <span class="hljs-keyword">of</span> elements) &#123;<br>            <span class="hljs-keyword">let</span> childrenElements = el.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">children</span><br>            <span class="hljs-keyword">let</span> noteId = <span class="hljs-title function_">getNoteId</span>(childrenElements[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">let</span> userId = <span class="hljs-title function_">getUserId</span>(childrenElements[<span class="hljs-number">2</span>])<br>            <span class="hljs-title function_">sendRequest</span>(&#123; type, userId, noteId &#125;)<br>        &#125;<br>        location.<span class="hljs-title function_">reload</span>()<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过当前路径返回笔记类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 笔记类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> currentPath = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span><br>    <span class="hljs-keyword">let</span> searchParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(currentPath.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">let</span> channelValue = searchParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;channel_id&#x27;</span>)<br>    <span class="hljs-keyword">let</span> match = channelValue.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/homefeed.(.*?)_v3/</span>)<br>    <span class="hljs-keyword">if</span> (match &amp;&amp; match[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> match[<span class="hljs-number">1</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入a标签获取笔记id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Element</span>&#125; <span class="hljs-variable">el</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 笔记id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNoteId</span>(<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-keyword">let</span> url = el.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>)<br>    <span class="hljs-keyword">var</span> match = url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\/explore\/(.*)/</span>)<br>    <span class="hljs-keyword">if</span> (match &amp;&amp; match[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> match[<span class="hljs-number">1</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入footer获取作者id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Element</span>&#125; <span class="hljs-variable">el</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 作者id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserId</span>(<span class="hljs-params">el</span>) &#123;<br>    el = el.<span class="hljs-property">children</span>[<span class="hljs-number">1</span>].<span class="hljs-property">children</span>[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> url = el.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>)<br>    <span class="hljs-keyword">let</span> match = url.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\/user\/profile\/(.*)/</span>)<br>    <span class="hljs-keyword">if</span> (match &amp;&amp; match[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">return</span> match[<span class="hljs-number">1</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendRequest</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;http://localhost:端口/接口路径&#x27;</span><br>    <span class="hljs-title function_">fetch</span>(url, &#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>    &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="RPC爬虫"><a href="#RPC爬虫" class="headerlink" title="RPC爬虫"></a>RPC爬虫</h1>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指定git使用某个ssh私钥</title>
    <link href="/2024/01/25/%E6%8C%87%E5%AE%9Agit%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AAssh%E7%A7%81%E9%92%A5/"/>
    <url>/2024/01/25/%E6%8C%87%E5%AE%9Agit%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AAssh%E7%A7%81%E9%92%A5/</url>
    
    <content type="html"><![CDATA[<p>以前使用不当，使得电脑上有多个ssh密钥对在不同的位置，连接github等仓库时不知道使用的哪一个密钥对</p><p>在~&#x2F;.ssh下新建config文件，内容设置为:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># Default github user self</span><br>Host github.com<br>port <span class="hljs-number">22</span><br>HostName ssh.github.com<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa<br></code></pre></td></tr></table></figure><p>搞定</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客部署到服务器</title>
    <link href="/2023/04/27/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/04/27/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/qq_38733240/article/details/108140565?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-108140565-blog-124471586.235%5Ev32%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-108140565-blog-124471586.235%5Ev32%5Epc_relevant_default_base&utm_relevant_index=2">第一篇</a><br><a href="https://blog.csdn.net/u013190417/article/details/122694959">第二篇</a></p><p>但能搜到的基本都使用宝塔面板，实在不想装宝塔，因此自己配置 nginx</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="nodejs-环境"><a href="#nodejs-环境" class="headerlink" title="nodejs 环境"></a>nodejs 环境</h2><p>首先搭建 nodejs 环境，使用 nvm 工具安装指定版本</p><p>先安装<a href="https://nvm.uihtm.com/download.html">nvm 工具</a>，版本随意，一路 next 安装即可</p><p>安装完毕后，打开 cmd，使用 nvm install 指令安装指定版本的 nodejs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm install 18.15.0<br></code></pre></td></tr></table></figure><p>然后用 nvm list 查看是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm list<br></code></pre></td></tr></table></figure><p>看到版本号前的星号就表示安装成功，并且当前使用该版本</p><p><img src="https://wolf-blog-1314051886.cos.ap-guangzhou.myqcloud.com/20230427101039_5dc369d056bbbc7ac8316ae067fe4404.png" alt="nvm list结果"></p><p>nvm 工具管理 nodejs 版本非常方便，其他指令可自行查询</p><h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><p><a href="https://hexo.io/zh-cn/">hexo 官网</a>，按照文档做即可创建博客项目，并轻松部署到 Github 上</p><h1 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h1><h2 id="配置-SSH-密钥"><a href="#配置-SSH-密钥" class="headerlink" title="配置 SSH 密钥"></a>配置 SSH 密钥</h2><p>能部署到 Github，SSH 密钥应该已经生成了，直接用已经生成过的好了，在 git bash 中查看公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p><img src="https://wolf-blog-1314051886.cos.ap-guangzhou.myqcloud.com/20230427102305_00b7997bf33985c6a968ba39c4fd645b.png" alt="cat ~/.ssh/id_rsa.pub"></p><p>把这一串，包括 ssh-rsa 的开头复制出来，待会用</p><p>登录到服务器，安装 git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install git<br></code></pre></td></tr></table></figure><p>然后创建一个 git 用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adduser git<br></code></pre></td></tr></table></figure><p>添加 git 用户权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 740 /etc/sudoers<br>vim /etc/sudoers<br></code></pre></td></tr></table></figure><p>在 vim 中修改 git 用户权限如下：</p><p><img src="https://wolf-blog-1314051886.cos.ap-guangzhou.myqcloud.com/20230427102823_23efa619fdd0fbcc0a104f4f31b0b713.png" alt="修改git用户权限"></p><p>把 sudoers 文件的权限改回来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 400 /etc/sudoers<br></code></pre></td></tr></table></figure><p>设置 git 用户的密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd git<br></code></pre></td></tr></table></figure><p>切换至 git 用户，然后把我们刚刚复制的公钥放到服务器上<br>先在 git 用户目录下创建文件夹和指定文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">su git<br>cd ~<br>mkdir .ssh<br>vim .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>在文本编辑器中，把我们的公钥粘贴进去，这个文件可以存放多个公钥：<br><img src="https://wolf-blog-1314051886.cos.ap-guangzhou.myqcloud.com/20230427103554_c9225616c51a533fdaf9f271f3c310c4.png" alt="用换行分隔"></p><p>保存退出后验证一下是否配置成功，用以下指令，再输入 yes，若不用密码能连接上服务器，说明 ssh 密钥配置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -v git@服务器ip<br></code></pre></td></tr></table></figure><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>用 root 用户创建一个仓库目录用于存放 hexo 部署时上传的代码，其实放哪都行，但所有参考博客都放 var 下，也跟着做了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /var/repo<br></code></pre></td></tr></table></figure><p>给 git 用户赋予访问权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R git:git /var/repo<br>chmod -R 755 /var/repo<br></code></pre></td></tr></table></figure><p>在这个目录下创建 git 仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/repo<br>git init --bare hexo.git<br></code></pre></td></tr></table></figure><p>创建一个 git 钩子，用于自动部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /var/repo/hexo.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>该文件中写入以下脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>git --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f<br></code></pre></td></tr></table></figure><p>给这个钩子文件赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R git:git /var/repo/hexo.git/hooks/post-receive<br>chmod +x /var/repo/hexo.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>创建 hexo 目录，作为 hexo 打包后存放的目录，也就是 nginx 配置中网站的根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /var/hexo<br>chown -R git:git /var/hexo<br>chmod -R 755 /var/hexo<br></code></pre></td></tr></table></figure><p>仓库创建配置完成</p><h2 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h2><p>刚刚提到过，hexo 目录，作为 hexo 打包后存放的目录，也就是 nginx 配置中网站的根目录</p><p>在 nginx 配置文件中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">server &#123;<br>    listen      80;<br>    server_name FrontEndServer;<br>    location /xxx &#123;<br>        alias /var/hexo;<br>        index index.html;<br>        try_files $uri $uri/ /xxx/index.html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新加载配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><h2 id="修改-hexo-配置文件"><a href="#修改-hexo-配置文件" class="headerlink" title="修改 hexo 配置文件"></a>修改 hexo 配置文件</h2><p>修改关于部署的部分</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@服务器ip或域名:/var/repo/hexo.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>但只改这部分，打包好后的 html 中引用的 css、js 文件都在服务器根目录下，显然这会找不到资源，因此配置_config.yml 中的网站根路径</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">url:</span> <span class="hljs-string">http(s)://域名/xxx</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/xxx/</span><br></code></pre></td></tr></table></figure><p>xxx 和 nginx 中配置的访问路径对应</p><h2 id="安装-hexo-部署插件"><a href="#安装-hexo-部署插件" class="headerlink" title="安装 hexo 部署插件"></a>安装 hexo 部署插件</h2><p>有些主题不一定包含 hexo-deployer-git 插件，因此安装一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i hexo-deployer-git<br></code></pre></td></tr></table></figure><h2 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h2><p>使用<code>hexo d -g</code>，快速将本地博客部署到服务器<br>done.</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官给您跪下了qaq</title>
    <link href="/2023/04/05/%E9%9D%A2%E8%AF%95%E4%B8%8D%E8%B6%B3/"/>
    <url>/2023/04/05/%E9%9D%A2%E8%AF%95%E4%B8%8D%E8%B6%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>基础概念详见<a href="https://www.xiaolincoding.com/network/1_base/tcp_ip_model.html">小林 coding</a></p><h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><h3 id="Wireshark-运行原理"><a href="#Wireshark-运行原理" class="headerlink" title="Wireshark 运行原理"></a>Wireshark 运行原理</h3><p>Wireshark 通过<strong>网络适配器（网卡）的混杂模式</strong>来捕获网络上的数据包。在混杂模式下，网卡不仅接收本机的数据包，也能接收到其他设备的数据包，包括未被本机地址过滤的数据包。因此，Wireshark 能够捕获到整个网络中的数据包。</p><blockquote><p><strong>网络适配器（网卡）的混杂模式</strong>是一种工作模式，它使得网络适配器能够接收并处理网络上所有经过的数据包，而不仅仅是目标地址是它自己的数据包。<br>通常情况下，网络适配器只会接收那些目标地址是自己的数据包，而将其他数据包直接丢弃。但是，当网络适配器处于混杂模式下时，它会接收网络上的所有数据包，并将它们传递给<strong>上层的网络协议栈</strong>进行处理。<br>混杂模式通常用于网络分析和网络安全领域。比如，网络管理员可以使用混杂模式来捕获网络上的数据包，以便分析网络性能或者检测网络中的安全漏洞。同时，黑客也可以利用混杂模式来进行网络监听和数据窃取等恶意行为。因此，在实际应用中，混杂模式需要谨慎使用。</p></blockquote><p>Wireshark 会利用网络适配器的混杂模式，通过底层的网络接口来访问网络数据包。Wireshark 通过套接字（socket）与<strong>操作系统的网络接口层（Network Interface Layer）</strong>进行交互，接收和处理从网络适配器捕获的数据包。</p><p>在 Wireshark 捕获数据包的过程中，它会设置网络适配器处于混杂模式下，使其可以捕获所有经过网络适配器的数据包，而不仅仅是目标 MAC 地址是它的 MAC 地址的数据包。当 Wireshark 打开时，它会开始在计算机的内存中创建一个缓冲区，用于存储接收到的数据包。Wireshark 使用 libpcap 库来访问底层网络接口，以便在数据包到达网络适配器时能够捕获它们，并将它们传递给 Wireshark 处理。</p><p>当 Wireshark 捕获到数据包后，它会将其解析为人类可读的形式，显示在主窗口中，同时还提供了过滤、统计、分析等功能，以便用户对数据包进行更加深入的分析和了解。需要注意的是，Wireshark 并不会修改或干扰网络中的数据包传输，它只是监听和分析这些数据包，因此不会对网络的性能和稳定性造成影响。</p><h4 id="Wireshark-可以安装在服务器上运行吗"><a href="#Wireshark-可以安装在服务器上运行吗" class="headerlink" title="Wireshark 可以安装在服务器上运行吗"></a>Wireshark 可以安装在服务器上运行吗</h4><p>如果将类似 Wireshark 功能的软件安装在服务器上，一般情况下是无法直接捕获到服务器发出的数据包的。因为服务器通常是通过网络接口卡（NIC）发送数据包的，<strong>如果该 NIC 不处于混杂模式下，那么只有目标主机可以接收到该数据包，其他主机是无法接收到该数据包的。</strong>如果想要在服务器上捕获数据包，需要将服务器的网络接口卡置于混杂模式下，这通常需要管理员权限。</p><h4 id="Wireshark-如何捕获并解密-https-协议的数据包"><a href="#Wireshark-如何捕获并解密-https-协议的数据包" class="headerlink" title="Wireshark 如何捕获并解密 https 协议的数据包"></a>Wireshark 如何捕获并解密 https 协议的数据包</h4><p>面试的时候遇到这个真的抓瞎了，不过居然还猜的八九不离十。</p><p>能解密出 https 数据包中的内容，那 Wireshark 手上必然持有服务器在 SSL 四次握手中发来的数字证书（公钥）。也就是说 Wireshark 本质上进行了一次<strong>中间人攻击</strong>，是真的把数据包拦截下来，再发出去，而不是在数据包发出的过程中偷偷复制一份。</p><p>具体来说，Wireshark 在运行时可以利用本机上已经安装的 SSL&#x2F;TLS 根证书，伪造一个与服务器通信的 TLS 连接，并在客户端中欺骗客户端与服务器之间的 SSL&#x2F;TLS 握手，从而使客户端将数据发送给 Wireshark。Wireshark 利用伪造的 TLS 连接与客户端进行通信，同时也会伪造与服务器的连接，并将数据转发给服务器，使得服务器也认为自己在与客户端进行通信。因此，Wireshark 就能够捕获到服务器返回的加密数据，并通过伪造的 TLS 连接将其解密并展示给用户。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="手写-Promise-all"><a href="#手写-Promise-all" class="headerlink" title="手写 Promise.all"></a>手写 Promise.all</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = []<br>    <span class="hljs-comment">// 已完成的promise个数</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        count++<br>        result[index] = value<br>        <span class="hljs-comment">// 全部完成才resolve</span><br>        <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>)<br>          <span class="hljs-title function_">resolve</span>(result)<br>      &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 有一个失败就返回reject</span><br>        <span class="hljs-title function_">reject</span>(reason)<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手写-Prmise-race"><a href="#手写-Prmise-race" class="headerlink" title="手写 Prmise.race"></a>手写 Prmise.race</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseRace</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 根据第一个完成的结果决定返回类型</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(resolve, reject)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖的作用是，事件触发后隔一段时间才执行；如果期间再次触发，重置计时器。也就是说，如果事件触发频率过高，只有最后一次生效（只生效一次）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, time</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span> <span class="hljs-comment">// 创建一个标记用来存放定时器的返回值</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-built_in">clearTimeout</span>(timeout) <span class="hljs-comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span><br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span><br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    &#125;, time)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流的作用是，事件触发后隔一段时间才执行，等待期间再次触发事件均不执行回调，直到等待时间结束，本次事件执行完毕，才可以触发这个事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, time</span>) &#123;<br>  <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span> <span class="hljs-comment">// 通过闭包保存一个标记</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 在函数开头判断标记是否为true，不为true则return</span><br>    canRun = <span class="hljs-literal">false</span> <span class="hljs-comment">// 立即设置为false</span><br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-keyword">const</span> timer = time ? <span class="hljs-built_in">setTimeout</span> : requestAnimationFrame<br>    <span class="hljs-title function_">timer</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 将外部传入的函数的执行放在setTimeout中</span><br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      <span class="hljs-comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span><br>      canRun = <span class="hljs-literal">true</span><br>    &#125;, time)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种写法，通过时间戳判断是否可以触发事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, time</span>) &#123;<br>  <span class="hljs-keyword">let</span> front = <span class="hljs-number">0</span> <span class="hljs-comment">// 通过闭包保存一个标记</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-keyword">if</span> (now - front &lt;= time) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 上一次未结束</span><br>    front = now<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-keyword">const</span> timer = time ? <span class="hljs-built_in">setTimeout</span> : requestAnimationFrame<br>    <span class="hljs-title function_">timer</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    &#125;, time)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>举个栗子，百度的搜索框，输入事件触发后调用搜索接口，但肯定不希望接口调用过快。首先我们希望保证每输入一个字都搜索一次的效果（输入较慢的情况下），因此还是得用节流。但我们由希望结果由最后一次输入决定，因此节流的内部又需要使用防抖，因此用如下代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">both</span>(<span class="hljs-params">fn, time</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">let</span> front = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-comment">// 先节流</span><br>    <span class="hljs-keyword">if</span> (now - front &gt; time) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timeout)<br>      front = now<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 内部使用防抖</span><br>      <span class="hljs-built_in">clearTimeout</span>(timeout)<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="常见攻击方式"><a href="#常见攻击方式" class="headerlink" title="常见攻击方式"></a>常见攻击方式</h2><ul><li><p><strong>DDOS 攻击</strong>：DDoS 是 Distributed Denial of Service 的缩写，指的是分布式拒绝服务攻击。攻击者会通过多个主机对目标主机发起大量的请求，使目标主机无法正常处理其他合法用户的请求，从而导致服务不可用。</p></li><li><p><strong>SQL 注入攻击</strong>：SQL 注入攻击是指攻击者通过构造恶意 SQL 语句来非法访问和篡改数据库中的数据，甚至可以通过注入攻击获取数据库的敏感信息。</p></li><li><p><strong>XSS 攻击</strong>：XSS 攻击是指攻击者在网站中注入恶意代码，当用户访问这个网站时，恶意代码就会执行，从而导致用户信息泄露、篡改或者其他安全问题。</p></li><li><p><strong>CSRF 攻击</strong>：CSRF 攻击是指攻击者通过某种方式让用户在不知情的情况下发送恶意请求，从而实现对用户的攻击。攻击者可以利用用户的已有会话进行攻击，获取敏感信息或执行恶意操作。</p></li><li><p><strong>木马攻击</strong>：木马攻击是指通过隐藏在合法程序中的恶意代码，在用户不知情的情况下获取用户敏感信息或者控制用户计算机等行为。</p></li><li><p><strong>社交工程攻击</strong>：社交工程攻击是指攻击者通过欺骗和诱导等手段来获取用户的敏感信息，例如通过钓鱼邮件、虚假网站等手段获取用户的账号和密码等信息。</p></li></ul><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>XSS 攻击（Cross-site scripting attack）是一种常见的网络安全漏洞，攻击者通过注入恶意脚本到网页中，使用户浏览器执行这些脚本，从而达到攻击的目的。XSS 攻击可以分为两种类型：反射型和存储型。<br>反射型 XSS 攻击是指攻击者将恶意脚本注入到 URL 中，当用户点击链接或者访问这个 URL 时，恶意脚本就会被执行。这种攻击方式的特点是，恶意脚本仅仅被执行一次，攻击者需要引诱用户点击链接或者访问特定的 URL，才能实现攻击。<br>存储型 XSS 攻击是指攻击者将恶意脚本存储到服务器端的数据库中，当用户访问包含这些恶意脚本的页面时，恶意脚本就会被执行。这种攻击方式的特点是，恶意脚本被多次执行，攻击者可以通过存储恶意脚本的方式来攻击更多的用户。<br>XSS 攻击的危害非常严重，攻击者可以通过恶意脚本获取用户的敏感信息，例如账号、密码等，或者利用恶意脚本对用户进行其他各种攻击，例如强制用户进行某些操作、篡改网页内容等。</p><p>为了防范 XSS 攻击，我们可以采取以下措施：</p><ul><li><p>对用户输入进行过滤和验证，禁止输入特定的字符和标签，例如 ‘&lt;’ 和 ‘&gt;’，从而避免注入恶意脚本。</p></li><li><p>对用户输入进行编码，例如将 &lt; 转义，避免浏览器将其识别为 HTML 标签，从而避免注入恶意脚本。</p></li><li><p>在网页中添加 CSP（Content Security Policy）头信息，限制恶意脚本的执行，例如限制脚本的来源和执行方式，从而提高网站的安全性。</p></li><li><p>使用 HTTP-only Cookie，避免攻击者通过 JavaScript 访问 Cookie，从而避免被攻击者窃取用户信息的风险。</p></li><li><p>定期对网站进行漏洞扫描和安全评估，及时发现和修复漏洞，提高网站的安全性。</p></li></ul><h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><p>CSRF（Cross-site request forgery，跨站请求伪造）攻击指的是攻击者利用用户已经登录的身份，在用户不知情的情况下，完成某些非法操作或者获取某些敏感信息。</p><p>攻击流程一般如下：</p><ol><li><p>用户在浏览器中打开了一个可信的网站 A 并进行登录操作，此时 A 网站会在用户的浏览器中生成一个 cookie，用于标识用户的身份。</p></li><li><p>用户在不退出 A 网站的情况下，在浏览器中打开一个恶意网站 B。</p></li><li><p>恶意网站 B 中构造了一个向 A 网站的请求，请求中包含了 A 网站某个接口的地址以及需要传递的参数，然后将该请求发送给用户的浏览器。</p></li><li><p>用户的浏览器在发送该请求时，会自动携带 A 网站生成的 cookie，A 网站会认为是用户本人发起的请求，并根据请求中的参数完成相应的操作。</p></li><li><p>恶意网站 B 就成功地完成了一次 CSRF 攻击。</p></li></ol><p>为了防止 CSRF 攻击，可以采用以下几种措施：</p><ul><li><p>在请求中添加 token。在用户登录成功后，后端生成一个 token 并返回给前端，前端将该 token 保存在 cookie 或者 localStorage 中，然后在发送请求时，将该 token 一并携带到请求头中。后端在接收到请求时，校验该 token 是否合法，只有合法的请求才会被处理。</p></li><li><p>在请求头中添加 Referer。在浏览器中发送请求时，会在请求头中自动添加 Referer 字段，该字段的值为当前请求页面的地址。后端可以通过该字段来判断请求是否来自合法的页面。</p></li><li><p>在 cookie 中添加 SameSite 属性。该属性可以限制 cookie 的跨站访问行为，只有同站点的请求才可以携带该 cookie。设置该属性的方式如下：</p></li></ul><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">Set</span>-Cookie: name=value; SameSite=<span class="hljs-keyword">Strict</span>;<br></code></pre></td></tr></table></figure><ul><li>阻止第三方 Cookie。在浏览器中可以设置禁止第三方 cookie 的设置，可以有效地防止跨站攻击。</li></ul><h1 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h1><h2 id="若后端使用-token-储存用户权限进行鉴权，token-丢失-x2F-被窃取如何解决"><a href="#若后端使用-token-储存用户权限进行鉴权，token-丢失-x2F-被窃取如何解决" class="headerlink" title="若后端使用 token 储存用户权限进行鉴权，token 丢失&#x2F;被窃取如何解决"></a>若后端使用 token 储存用户权限进行鉴权，token 丢失&#x2F;被窃取如何解决</h2><ul><li><p><strong>使用 HTTPS 协议进行通信</strong>：通过使用 HTTPS 协议进行通信，可以加密客户端和服务器之间的通信，从而提高系统的安全性，防止数据被窃取或篡改。</p></li><li><p><strong>设置 token 过期时间</strong>：在为用户生成 token 时，可以设置一个较短的过期时间，让 token 在一定时间后失效。这样可以减少 token 被盗用的风险，同时也可以保护用户的隐私安全。</p></li><li><p><strong>使用 token 刷新机制</strong>：在用户的 token 快要过期时，服务器可以通过向客户端发送一个 refresh token 的方式，让客户端重新获取新的 token。这样可以减少 token 被盗用的风险，同时也可以保证用户的持续访问权限。</p></li><li><p><strong>定期更换 token</strong>：在用户的 token 使用一定次数或者一定时间后，服务器可以定期更换用户的 token。这样可以防止 token 被盗用或者泄露后长时间被滥用，从而提高系统的安全性。</p></li><li><p><strong>监控 token 使用情况</strong>：在系统中，可以通过日志记录和监控等方式，对用户的 token 使用情况进行跟踪和监控。如果发现异常情况，例如 token 被多次使用或者 token 来自异常 IP 地址等，可以立即进行相应的安全防护措施。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟DOM学习</title>
    <link href="/2023/03/20/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/20/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟-DOM-介绍"><a href="#虚拟-DOM-介绍" class="headerlink" title="虚拟 DOM 介绍"></a>虚拟 DOM 介绍</h1><p>早期 Web 开发中，视图改变都需要程序员手动修改 DOM。直到 jQuery 的时代，DOM 操作有了极大的简化，但仍然需要我们频繁操作 DOM 实现页面效果和交互。</p><p>随着数据驱动视图思想的出现，Vue 和 React 两大开发框架面世，提出了一个新的概念——虚拟 DOM。虚拟 DOM 是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点。数据改变后，通过修改这个对象，然后把它与真实 DOM 进行比较，最后仅修改必要的 DOM 节点，就能完成视图更新。而这个 DOM 比较的算法就是 diff 算法。在不同开发框架，同一开发框架的不同版本中，diff 算法都有不同实现，<strong>diff 算法发生在虚拟 DOM 上</strong>。</p><h2 id="虚拟-DOM-对象举例"><a href="#虚拟-DOM-对象举例" class="headerlink" title="虚拟 DOM 对象举例"></a>虚拟 DOM 对象举例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 真实DOM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/* 虚拟DOM */</span><br>&#123;<br>  <span class="hljs-attr">sel</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">class</span>: &#123; <span class="hljs-attr">box</span>: <span class="hljs-literal">true</span> &#125;<br>  &#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">sel</span>: <span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-attr">data</span>: &#123;&#125;, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;标题&#x27;</span> &#125;,<br>    &#123;<br>      <span class="hljs-attr">sel</span>: <span class="hljs-string">&#x27;ul&#x27;</span>,<br>      <span class="hljs-attr">data</span>: &#123;&#125;,<br>      <span class="hljs-attr">children</span>: [<br>        &#123; <span class="hljs-attr">sel</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">data</span>: &#123;&#125;, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;列表项1&#x27;</span> &#125;,<br>        &#123; <span class="hljs-attr">sel</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">data</span>: &#123;&#125;, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;列表项2&#x27;</span> &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="diff-算法的起始——Snabbdom"><a href="#diff-算法的起始——Snabbdom" class="headerlink" title="diff 算法的起始——Snabbdom"></a>diff 算法的起始——Snabbdom</h1><p><a href="https://github.com/snabbdom/snabbdom">Snabbdom 项目 Github 地址</a></p><p>Snabbdom 是一个虚拟 DOM 库，其核心代码只有约 200 行。下面先跑通 Snabbdom 的官方样例代码。</p><h2 id="Snabbdom-样例代码"><a href="#Snabbdom-样例代码" class="headerlink" title="Snabbdom 样例代码"></a>Snabbdom 样例代码</h2><p>先搭建运行环境。作为一个虚拟 DOM 库，当然不能运行在 nodejs 环境，因此先搭建 webpack-dev-server。</p><p>初始化项目，并安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm init<br>npm i -D snabbdom<br>npm i --legacy-peer-deps -D webpack@5 webpack-cli@3 webpack-dev-server@3<br></code></pre></td></tr></table></figure><p>配置 webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/* webpack.config.js */</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;fake&#x27;</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,<br>    <span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;www&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>创建 src 和 www 目录，分别创建 index.js 和 html 文件后，此时项目目录结构如下：<br><img src="/img/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/Snabbdom/Snabbdom%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84.jpg" alt="Snabbdom初始化项目结构"></p><p>复制 Snabbdom 官方样例代码到 index.js 中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/* src/index.js */</span><br><span class="hljs-keyword">import</span> &#123;<br>  init,<br>  classModule,<br>  propsModule,<br>  styleModule,<br>  eventListenersModule,<br>  h,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;snabbdom&quot;</span><br><br><span class="hljs-keyword">const</span> patch = <span class="hljs-title function_">init</span>([<br>  <span class="hljs-comment">// 通过传入模块初始化 patch 函数</span><br>  classModule, <span class="hljs-comment">// 开启 classes 功能</span><br>  propsModule, <span class="hljs-comment">// 支持传入 props</span><br>  styleModule, <span class="hljs-comment">// 支持内联样式同时支持动画</span><br>  eventListenersModule, <span class="hljs-comment">// 添加事件监听</span><br>])<br><br><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;container&quot;</span>)<br><br><span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div#container.two.classes&quot;</span>, &#123; <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125; &#125;, [<br>  <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;span&quot;</span>, &#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&quot;bold&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;This is bold&quot;</span>),<br>  <span class="hljs-string">&quot; and this is just normal text&quot;</span>,<br>  <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;/foo&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;I&#x27;ll take you places!&quot;</span>),<br>])<br><span class="hljs-comment">// 传入一个空的元素节点 - 将产生副作用（修改该节点）</span><br><span class="hljs-title function_">patch</span>(container, vnode)<br><br><span class="hljs-keyword">const</span> newVnode = <span class="hljs-title function_">h</span>(<br>  <span class="hljs-string">&quot;div#container.two.classes&quot;</span>,<br>  &#123; <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125; &#125;,<br>  [<br>    <span class="hljs-title function_">h</span>(<br>      <span class="hljs-string">&quot;span&quot;</span>,<br>      &#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&quot;normal&quot;</span>, <span class="hljs-attr">fontStyle</span>: <span class="hljs-string">&quot;italic&quot;</span> &#125; &#125;,<br>      <span class="hljs-string">&quot;This is now italic type&quot;</span><br>    ),<br>    <span class="hljs-string">&quot; and this is still just normal text&quot;</span>,<br>    <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;/bar&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;I&#x27;ll take you places!&quot;</span>),<br>  ]<br>)<br><span class="hljs-comment">// 再次调用 `patch`</span><br><span class="hljs-title function_">patch</span>(vnode, newVnode) <span class="hljs-comment">// 将旧节点更新为新节点</span><br></code></pre></td></tr></table></figure><p>观察代码可知，需要一个 id 为 container 的 div。因此在 index.html 中创建该 div 元素，并用 script 标签引入 webpack 打包后的虚拟 bundle.js 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/fake/bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 package.json 中配置好 dev 脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">/* package.json部分 */</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>npm run dev 运行该脚本，即可访问 <a href="http://localhost:8080/">http://localhost:8080</a> 观察样例代码运行结果</p><p><img src="/img/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/Snabbdom/Snabbdom%E6%A0%B7%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="Snabbdom样例代码运行结果"></p><h2 id="样例代码研究"><a href="#样例代码研究" class="headerlink" title="样例代码研究"></a>样例代码研究</h2><p>再贴一次样例代码方便观察</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/* src/index.js */</span><br><span class="hljs-keyword">import</span> &#123;<br>  init,<br>  classModule,<br>  propsModule,<br>  styleModule,<br>  eventListenersModule,<br>  h,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;snabbdom&quot;</span><br><br><span class="hljs-keyword">const</span> patch = <span class="hljs-title function_">init</span>([<br>  <span class="hljs-comment">// 通过传入模块初始化 patch 函数</span><br>  classModule, <span class="hljs-comment">// 开启 classes 功能</span><br>  propsModule, <span class="hljs-comment">// 支持传入 props</span><br>  styleModule, <span class="hljs-comment">// 支持内联样式同时支持动画</span><br>  eventListenersModule, <span class="hljs-comment">// 添加事件监听</span><br>])<br><br><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;container&quot;</span>)<br><br><span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div#container.two.classes&quot;</span>, &#123; <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125; &#125;, [<br>  <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;span&quot;</span>, &#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&quot;bold&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;This is bold&quot;</span>),<br>  <span class="hljs-string">&quot; and this is just normal text&quot;</span>,<br>  <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;/foo&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;I&#x27;ll take you places!&quot;</span>),<br>])<br><span class="hljs-comment">// 传入一个空的元素节点 - 将产生副作用（修改该节点）</span><br><span class="hljs-title function_">patch</span>(container, vnode)<br><br><span class="hljs-keyword">const</span> newVnode = <span class="hljs-title function_">h</span>(<br>  <span class="hljs-string">&quot;div#container.two.classes&quot;</span>,<br>  &#123; <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125; &#125;,<br>  [<br>    <span class="hljs-title function_">h</span>(<br>      <span class="hljs-string">&quot;span&quot;</span>,<br>      &#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&quot;normal&quot;</span>, <span class="hljs-attr">fontStyle</span>: <span class="hljs-string">&quot;italic&quot;</span> &#125; &#125;,<br>      <span class="hljs-string">&quot;This is now italic type&quot;</span><br>    ),<br>    <span class="hljs-string">&quot; and this is still just normal text&quot;</span>,<br>    <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;/bar&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;I&#x27;ll take you places!&quot;</span>),<br>  ]<br>)<br><span class="hljs-comment">// 再次调用 `patch`</span><br><span class="hljs-title function_">patch</span>(vnode, newVnode) <span class="hljs-comment">// 将旧节点更新为新节点</span><br></code></pre></td></tr></table></figure><p>首先不难猜出，h 函数的作用就是创建一个虚拟 DOM 节点，下面点进 h 函数阅读 ts 源码（已加上注释）</p><h2 id="Snabbdom-源码阅读"><a href="#Snabbdom-源码阅读" class="headerlink" title="Snabbdom 源码阅读"></a>Snabbdom 源码阅读</h2><h3 id="h-函数——用于创建虚拟节点"><a href="#h-函数——用于创建虚拟节点" class="headerlink" title="h 函数——用于创建虚拟节点"></a>h 函数——用于创建虚拟节点</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">sel: <span class="hljs-built_in">any</span>, b?: <span class="hljs-built_in">any</span>, c?: <span class="hljs-built_in">any</span></span>): <span class="hljs-title class_">VNode</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">VNodeData</span> = &#123;&#125;;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">children</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">text</span>: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">if</span> (c !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-comment">/* data就是class等属性 */</span><br>    <span class="hljs-keyword">if</span> (b !== <span class="hljs-literal">null</span>) &#123;<br>      data = b;<br>    &#125;<br>    <span class="hljs-comment">/* 参数c是一个数组，则数组内部每一项都是虚拟DOM对象，都是这个节点的孩子 */</span><br>    <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">array</span>(c)) &#123;<br>      children = c;<br>    &#125;<br>    <span class="hljs-comment">/* 参数c是string或number，则这个节点里的文本内容就是参数c */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">primitive</span>(c)) &#123;<br>      text = c.<span class="hljs-title function_">toString</span>();<br>    &#125;<br>    <span class="hljs-comment">/* 根据c的sel属性存在，可以得知参数c也是一个虚拟DOM对象 */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &amp;&amp; c.<span class="hljs-property">sel</span>) &#123;<br>      children = [c];<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">/* 只有两个参数，没有c，进行一样的判断 */</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b !== <span class="hljs-literal">undefined</span> &amp;&amp; b !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">array</span>(b)) &#123;<br>      children = b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">primitive</span>(b)) &#123;<br>      text = b.<span class="hljs-title function_">toString</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &amp;&amp; b.<span class="hljs-property">sel</span>) &#123;<br>      children = [b];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      data = b;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (children !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; ++i) &#123;<br>      <span class="hljs-comment">/* 如果children中的某一项不是一个对象，只是一个string或number，那么生成一个虚拟DOM包裹这个文本内容 */</span><br>      <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">primitive</span>(children[i]))<br>        children[i] = <span class="hljs-title function_">vnode</span>(<br>          <span class="hljs-literal">undefined</span>, <span class="hljs-comment">/* sel */</span><br>          <span class="hljs-literal">undefined</span>, <span class="hljs-comment">/* data */</span><br>          <span class="hljs-literal">undefined</span>, <span class="hljs-comment">/* children */</span><br>          children[i], <span class="hljs-comment">/* text */</span><br>          <span class="hljs-literal">undefined</span> <span class="hljs-comment">/* elm */</span><br>        );<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<br>    sel[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;s&quot;</span> &amp;&amp;<br>    sel[<span class="hljs-number">1</span>] === <span class="hljs-string">&quot;v&quot;</span> &amp;&amp;<br>    sel[<span class="hljs-number">2</span>] === <span class="hljs-string">&quot;g&quot;</span> &amp;&amp;<br>    (sel.<span class="hljs-property">length</span> === <span class="hljs-number">3</span> || sel[<span class="hljs-number">3</span>] === <span class="hljs-string">&quot;.&quot;</span> || sel[<span class="hljs-number">3</span>] === <span class="hljs-string">&quot;#&quot;</span>)<br>  ) &#123;<br>    <span class="hljs-title function_">addNS</span>(data, children, sel);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">vnode</span>(sel, data, children, text, <span class="hljs-literal">undefined</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数还是相当好理解的，根据参数的类型和数量，返回一个 VNode 类型的对象（vnode 函数返回 new 出来的），也就是一个虚拟 DOM 节点</p><h3 id="h-函数的返回值——VNode-对象"><a href="#h-函数的返回值——VNode-对象" class="headerlink" title="h 函数的返回值——VNode 对象"></a>h 函数的返回值——VNode 对象</h3><p>既然 h 函数返回的是一个 VNode 对象，那接下来看看这个类是个什么东西</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Key</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">symbol</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VNode</span> &#123;<br>  <span class="hljs-attr">sel</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;                      <span class="hljs-comment">// selector，选择器，DOM节点的标签</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-title class_">VNodeData</span> | <span class="hljs-literal">undefined</span>;                  <span class="hljs-comment">// 节点属性，详细定义见下面VNodeData</span><br>  <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">VNode</span> | <span class="hljs-built_in">string</span>&gt; | <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// 子结点</span><br>  <span class="hljs-attr">elm</span>: <span class="hljs-title class_">Node</span> | <span class="hljs-literal">undefined</span>;                        <span class="hljs-comment">// 剧透，这个属性是对应的真实DOM节点，undefined表示这个虚拟节点未上树</span><br>  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;                     <span class="hljs-comment">// 节点内部</span><br>  <span class="hljs-attr">key</span>: <span class="hljs-title class_">Key</span> | <span class="hljs-literal">undefined</span>;                         <span class="hljs-comment">// 节点唯一标识，Vue里的key就是这个东西啦</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VNodeData</span> &#123;<br>  props?: <span class="hljs-title class_">Props</span>;<br>  attrs?: <span class="hljs-title class_">Attrs</span>;<br>  <span class="hljs-keyword">class</span>?: <span class="hljs-title class_">Classes</span>;<br>  style?: <span class="hljs-title class_">VNodeStyle</span>;<br>  dataset?: <span class="hljs-title class_">Dataset</span>;<br>  on?: <span class="hljs-title class_">On</span>;<br>  attachData?: <span class="hljs-title class_">AttachData</span>;<br>  hook?: <span class="hljs-title class_">Hooks</span>;<br>  key?: <span class="hljs-title class_">Key</span>;<br>  ns?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// for SVGs</span><br>  fn?: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">VNode</span>; <span class="hljs-comment">// for thunks</span><br>  args?: <span class="hljs-built_in">any</span>[]; <span class="hljs-comment">// for thunks</span><br>  is?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// for custom elements v1</span><br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// for any other 3rd party module</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这下虚拟 DOM 节点对象的结构就非常清楚了，但还有个小小的问题，props 和 attrs 的区别是什么呢？<br>可以学习这 2 篇博客：</p><ul><li><a href="https://www.bbsmax.com/A/GBJr7NBB50/">DOM 中 property 和 attribute 详解 1</a></li><li><a href="https://www.bbsmax.com/A/gAJGGAr8JZ/">DOM 中 property 和 attribute 详解 2</a></li></ul><p>简单的总结一下就是，这两者的区分没有什么规则，但有一定规律，并且 props 是 DOM 元素初始化时自带的一些属性<br>了解清楚创建虚拟 DOM 节点的过程后，下一步开始学习将这个节点渲染到真实 DOM 上的过程</p><h3 id="把虚拟-DOM-节点对象渲染到真实-DOM"><a href="#把虚拟-DOM-节点对象渲染到真实-DOM" class="headerlink" title="把虚拟 DOM 节点对象渲染到真实 DOM"></a>把虚拟 DOM 节点对象渲染到真实 DOM</h3><p>首先，我们先截取出样例代码的第一个虚拟 DOM，也就是 vnode 的渲染这一块，并且把最外层 h 函数中的 id 改成 outer：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;container&quot;</span>)<br><br><span class="hljs-comment">// 注意这里id换成了outer</span><br><span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div#outer.two.classes&quot;</span>, &#123; <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> &#123; &#125; &#125; &#125;, [<br>  <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;span&quot;</span>, &#123; <span class="hljs-attr">style</span>: &#123; <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&quot;bold&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;This is bold&quot;</span>),<br>  <span class="hljs-string">&quot; and this is just normal text&quot;</span>,<br>  <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;/foo&quot;</span> &#125; &#125;, <span class="hljs-string">&quot;I&#x27;ll take you places!&quot;</span>),<br>])<br><br><span class="hljs-title function_">patch</span>(container, vnode)<br></code></pre></td></tr></table></figure><p>如果只运行这部分代码，页面会呈现什么样子呢，下面是页面的效果和 html 结构<br><img src="/img/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/Snabbdom/%E4%BF%AE%E6%94%B9id%E4%B8%BAouter%E5%90%8E%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg" alt="页面效果和html结构"><br>body 下的 div 的 id 变成了 outer，那 patch 函数的作用就非常明显了，就是替换掉真实 DOM 元素！<br>但这个过程显然不可能是把整个真实的 DOM 节点直接替换，这样开销实在是太大了。因此 patch 函数内部的逻辑必然是只替换内容有改变，或插入新增的 DOM 元素，本文心心念念的第一个 diff 算法就在里面！</p><p>而 patch 函数是通过 init 函数生成的，因此让我们深入到 init 函数中</p><h4 id="init-函数——返回实现-diff-函数的-patch"><a href="#init-函数——返回实现-diff-函数的-patch" class="headerlink" title="init 函数——返回实现 diff 函数的 patch"></a>init 函数——返回实现 diff 函数的 patch</h4><p>init 函数非常长，因此先抛开功能函数，直接关注 init 函数真实执行的部分</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span><br><span class="hljs-params">  modules: <span class="hljs-built_in">Array</span>&lt;Partial&lt;Module&gt;&gt;,</span><br><span class="hljs-params">  domApi?: DOMAPI,</span><br><span class="hljs-params">  options?: Options</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">cbs</span>: <span class="hljs-title class_">ModuleHooks</span> = &#123;<br>    <span class="hljs-attr">create</span>: [],<br>    <span class="hljs-attr">update</span>: [],<br>    <span class="hljs-attr">remove</span>: [],<br>    <span class="hljs-attr">destroy</span>: [],<br>    <span class="hljs-attr">pre</span>: [],<br>    <span class="hljs-attr">post</span>: [],<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">api</span>: <span class="hljs-variable constant_">DOMAPI</span> = domApi !== <span class="hljs-literal">undefined</span> ? domApi : htmlDomApi;<br><br>  <span class="hljs-comment">// 收集第三方模块提供的各种钩子</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> hook <span class="hljs-keyword">of</span> hooks) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">of</span> modules) &#123;<br>      <span class="hljs-keyword">const</span> currentHook = <span class="hljs-variable language_">module</span>[hook];<br>      <span class="hljs-keyword">if</span> (currentHook !== <span class="hljs-literal">undefined</span>) &#123;<br>        (cbs[hook] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>[]).<span class="hljs-title function_">push</span>(currentHook);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 一些功能函数</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params"></span><br><span class="hljs-params">    oldVnode: VNode | Element | DocumentFragment,</span><br><span class="hljs-params">    vnode: VNode</span><br><span class="hljs-params">  </span>): <span class="hljs-title class_">VNode</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">elm</span>: <span class="hljs-title class_">Node</span>, <span class="hljs-attr">parent</span>: <span class="hljs-title class_">Node</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">insertedVnodeQueue</span>: <span class="hljs-title class_">VNodeQueue</span> = [];<br>    <span class="hljs-comment">// 先执行第三方模块传入的pre钩子</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">pre</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">pre</span>[i]();<br><br>    <span class="hljs-comment">// 如果oldVnode是真实DOM，返回一个只有指向真实DOM的指针的虚拟DOM</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isElement</span>(api, oldVnode)) &#123;<br>      oldVnode = <span class="hljs-title function_">emptyNodeAt</span>(oldVnode);<br>    &#125;<br>    <span class="hljs-comment">// 同理，判断是否真实DocumentFragmentAt，返回虚拟的vnode对象</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDocumentFragment</span>(api, oldVnode)) &#123;<br>      oldVnode = <span class="hljs-title function_">emptyDocumentFragmentAt</span>(oldVnode);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断两个虚拟DOM对象的key、data类型、标签、id、class（标签、id和class都为空时判断内部文本内容类型）是否全都相同</span><br>    <span class="hljs-comment">// 是的话可以确定，新旧虚拟DOM指向同一个真实DOM（或者同一个template），需要替换内容</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldVnode, vnode)) &#123;<br>      <span class="hljs-title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue);<br>    &#125;<br>    <span class="hljs-comment">// 否则直接删掉旧虚拟DOM指向的真实DOM，给新的虚拟DOM创建真实DOM，接到父节点上</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      elm = oldVnode.<span class="hljs-property">elm</span>!;<br>      parent = api.<span class="hljs-title function_">parentNode</span>(elm) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span>;<br><br>      <span class="hljs-comment">// 这个函数用于递归创建出一整棵以vnode为根的真实DOM树</span><br>      <span class="hljs-title function_">createElm</span>(vnode, insertedVnodeQueue);<br><br>      <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">null</span>) &#123;<br>        api.<span class="hljs-title function_">insertBefore</span>(parent, vnode.<span class="hljs-property">elm</span>!, api.<span class="hljs-title function_">nextSibling</span>(elm));<br>        <span class="hljs-comment">// 传入虚拟DOM，批量递归删除真实DOM</span><br>        <span class="hljs-title function_">removeVnodes</span>(parent, [oldVnode], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后替换完毕后按顺序执行inserted钩子</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insertedVnodeQueue.<span class="hljs-property">length</span>; ++i) &#123;<br>      insertedVnodeQueue[i].<span class="hljs-property">data</span>!.<span class="hljs-property">hook</span>!.<span class="hljs-property">insert</span>!(insertedVnodeQueue[i]);<br>    &#125;<br>    <span class="hljs-comment">// 然后执行post钩子</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">post</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">post</span>[i]();<br>    <span class="hljs-keyword">return</span> vnode;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>只看这部分就可以发现，对 patch 函数的执行逻辑影响最大的，是<code>sameVnode(oldVnode, vnode)</code>的判断结果<br>而<code>sameVnode</code>的判断逻辑如注释所说，判断两个虚拟 DOM 对象的 key、data、标签、id、class（标签、id 和 class 都为空时判断内部文本内容类型）是否全都相同<br>也就是说，<strong>除非新旧虚拟 DOM 节点的 key、data 类型、标签、id、class 全都一样；或者都没有标签、id、class，但 key、data 类型 一样，且都没有文本内容；否则不会采用 diff 算法，而是直接删掉旧的真实 DOM，生成新的真实 DOM 换上。</strong></p><p>而进入<code>sameVnode(oldVnode, vnode)</code>的判断后，只执行了 patchVnode 这么一个函数，因此继续进入 patchVnode 函数</p><h4 id="patchVnode-函数——替换新旧虚拟-DOM-节点的孩子-x2F-文本内容"><a href="#patchVnode-函数——替换新旧虚拟-DOM-节点的孩子-x2F-文本内容" class="headerlink" title="patchVnode 函数——替换新旧虚拟 DOM 节点的孩子&#x2F;文本内容"></a>patchVnode 函数——替换新旧虚拟 DOM 节点的孩子&#x2F;文本内容</h4><p>先看两个功能函数，<code>addVnodes</code>和<code>removeVnodes</code><br>这两个功能函数看名字就知道是什么作用：</p><ul><li><code>function addVnodes(parentElm: Node,before: Node | null,vnodes: VNode[],startIdx: number,endIdx: number,insertedVnodeQueue: VNodeQueue)</code><strong>在 parentElm 内部，before 的前面批量插入 vnodes 数组从 startIdx 到 endIdx 的节点（创建真实 DOM 插入 parentElm 内）</strong></li><li><code>function removeVnodes(parentElm: Node,vnodes: VNode[],startIdx: number,endIdx: number)</code><strong>在真实 DOM 上的 parentElm 中，删掉 vnodes 数组[startIdx, endIdx]范围内的节点</strong></li></ul><p>这两个功能函数由于要执行第三方模块传入的钩子，以及 vnode 本身存在 data 中的钩子，因此还是比较复杂的，但不影响主线逻辑，因此不在这里展开。有兴趣还是建议阅读一下源码，尤其是<code>removeVnodes</code>，通过设置计数器，每次执行 destroy 钩子调用回调函数使计数器减一，确保执行完所有 destroy 钩子后，计数器为 0 时，才真正移除真实 DOM ，这里的设计非常有意思</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> oldVnode 旧的虚拟DOM节点对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> vnode 新的虚拟DOM节点对象</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> insertedVnodeQueue 为inserted钩子准备的队列</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@description</span> 完成新旧虚拟DOM中孩子/文本内容的替换</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span>(<span class="hljs-params"></span><br><span class="hljs-params">    oldVnode: VNode,</span><br><span class="hljs-params">    vnode: VNode,</span><br><span class="hljs-params">    insertedVnodeQueue: VNodeQueue</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-comment">// 被替换前先执行prepatch钩子</span><br>    <span class="hljs-keyword">const</span> hook = vnode.<span class="hljs-property">data</span>?.<span class="hljs-property">hook</span>;<br>    hook?.<span class="hljs-property">prepatch</span>?.(oldVnode, vnode);<br>    <span class="hljs-keyword">const</span> elm = (vnode.<span class="hljs-property">elm</span> = oldVnode.<span class="hljs-property">elm</span>)!;<br>    <span class="hljs-comment">// 两个vnode虚拟DOM对象地址都一样，那就不用替换了</span><br>    <span class="hljs-keyword">if</span> (oldVnode === vnode) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 只要新的vnode存在data，或者新旧vnode的文本内容不一样，就要执行update钩子，第三方模块和vnode自己的都要</span><br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">data</span> !== <span class="hljs-literal">undefined</span> || (<span class="hljs-title function_">isDef</span>(vnode.<span class="hljs-property">text</span>) &amp;&amp; vnode.<span class="hljs-property">text</span> !== oldVnode.<span class="hljs-property">text</span>)) &#123;<br>      vnode.<span class="hljs-property">data</span> ??= &#123;&#125;;<br>      oldVnode.<span class="hljs-property">data</span> ??= &#123;&#125;;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">update</span>.<span class="hljs-property">length</span>; ++i)<br>        cbs.<span class="hljs-property">update</span>[i](oldVnode, vnode);<br>      vnode.<span class="hljs-property">data</span>?.<span class="hljs-property">hook</span>?.<span class="hljs-property">update</span>?.(oldVnode, vnode);<br>    &#125;<br>    <span class="hljs-comment">// 找到新旧vnode的children（都是vnode，也就是虚拟DOM对象）</span><br>    <span class="hljs-keyword">const</span> oldCh = oldVnode.<span class="hljs-property">children</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>[];<br>    <span class="hljs-keyword">const</span> ch = vnode.<span class="hljs-property">children</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>[];<br><br>    <span class="hljs-comment">// 如果新的vnode没有文本内容</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode.<span class="hljs-property">text</span>)) &#123;<br>      <span class="hljs-comment">// 新的vnode和旧的vnode都有孩子</span><br>      <span class="hljs-comment">// TODO 先放着，待会再看</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-keyword">if</span> (oldCh !== ch) <span class="hljs-title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue);<br>      &#125;<br>      <span class="hljs-comment">// 只有新的vnode有孩子，这好办，清空这个真实DOM的文本内容，把新vnode下的孩子都转成真实DOM插入到这个节点就好了</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) api.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-title function_">addVnodes</span>(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, insertedVnodeQueue);<br>      &#125;<br>      <span class="hljs-comment">// 只有旧节点有孩子，新节点没有，也好办，直接删光真实DOM节点下的所有孩子就好（如果旧节点有孩子，说明没有文本内容，不用考虑TextContent）</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh)) &#123;<br>        <span class="hljs-title function_">removeVnodes</span>(elm, oldCh, <span class="hljs-number">0</span>, oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-comment">// 新旧节点都没有孩子，而且新节点也没有文本内容，那要做的变化就是把旧节点的文本内容清空</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) &#123;<br>        api.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&quot;&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 新vnode有文本内容，旧的vnode不知道有没有，但不全等（隐藏条件是，新vnode没有孩子）</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">text</span> !== vnode.<span class="hljs-property">text</span>) &#123;<br>      <span class="hljs-comment">// 旧vnode有孩子，但新vnode没有，和上面一样，直接删光真实DOM节点下的所有孩子就好</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh)) &#123;<br>        <span class="hljs-title function_">removeVnodes</span>(elm, oldCh, <span class="hljs-number">0</span>, oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-comment">// 设置文本内容</span><br>      api.<span class="hljs-title function_">setTextContent</span>(elm, vnode.<span class="hljs-property">text</span>!);<br>    &#125;<br>    <span class="hljs-comment">// 如果上面的判断都没进入，说明新旧节点都由文本内容（也就是都没有孩子），文本内容还完全一样</span><br><br>    <span class="hljs-comment">// 比对完新旧节点，两个虚拟DOM的孩子或文本内容已经换成新的虚拟DOM了</span><br>    hook?.<span class="hljs-property">postpatch</span>?.(oldVnode, vnode);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这个函数也是看起来长，实际上逻辑很好理解：</p><ul><li>如果新的 vnode 有文本内容，那最简单，把旧 vnode 指向的真实 DOM 的孩子清空（如果有的话），然后文本内容换成新 vnode 的内容就好了</li><li>如果新 vnode 没有文本内容，那进一步分情况讨论<ul><li>如果新 vnode 没有孩子，旧 vnode 也没有，那把真实 DOM 的文本内容清空</li><li>如果新 vnode 没有孩子，旧 vnode 有，把这个真实 DOM 下的孩子节点都删空（也就是 oldVnode 的 children 指向的真实 DOM）</li><li>如果新 vnode 有孩子，旧 vnode 没有，清空真实 DOM 的文本内容，然后为新 vnode 的孩子们创建真实 DOM，插入到新旧 vnode 共同指向的真实 DOM 中</li><li>如果新 vnode 有孩子，旧 vnode 也有，最麻烦的情况，调用了<code>updateChildren</code>函数处理（先经过新 vnode 与旧 vnode 的孩子数组地址是否一样的判断，孩子数组的地址都一样那就不需要更新孩子了）</li></ul></li></ul><p>理清楚这个判断逻辑后，真正需要耗费脑力的，就是这个<code>updateChildren</code>函数了。</p><p>但先不急着进入这个函数，先考虑一个小问题：patchVnode 函数执行完，就意味着 patch 函数的主要逻辑已经结束了，只剩下 inserted 和 post 钩子的执行，那 <strong>data 是在哪里更新的呢？？</strong> 难道说就是在<code>updateChildren</code>函数里，只要不调用 updateChildren，data 就不会更新？<br>下面先验证一下这个猜想</p><h4 id="寻找-vnode-的-data-的更新位置"><a href="#寻找-vnode-的-data-的更新位置" class="headerlink" title="寻找 vnode 的 data 的更新位置"></a>寻找 vnode 的 data 的更新位置</h4><p>根据上面的分析，我们知道，如果 patch 的第一个参数是一个真实 dom，只要第二个参数传入的虚拟 DOM vnode 的标签、selector 都和第一个参数一样，并且 data 不为空（可以是空对象，data 这个属性不是 null 或 undefine 就好了），<code>patch</code>就会调用<code>patchVnode</code>（如果不调用<code>patchVnode</code>，我们传入的新 vnode 会直接生成一个新的真实 DOM，data 就不算更新，而是删光原来的再新建一个）。<br>因此修改一下我们的 index.js，让 vnode 的 selector 与真实 DOM div 保持一致，然后给个新的 data（这里用 props 中的 href）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>你好<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/fake/bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;container&quot;</span>)<br><br><span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div#container&quot;</span>, &#123; <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125; &#125;, <span class="hljs-string">&#x27;哈哈&#x27;</span>)<br><br><span class="hljs-title function_">patch</span>(container, vnode)<br></code></pre></td></tr></table></figure><p>然后修改一下 snabbdom 源码（build 里的 js 文件，ts 只是阅读的，js 才是实际调用的）<br><img src="/img/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/Snabbdom/%E9%AA%8C%E8%AF%81vnode%E7%9A%84data%E7%9A%84%E6%9B%B4%E6%96%B0%E4%BD%8D%E7%BD%AE.jpg" alt="验证vnode的data的更新位置"><br>然后运行 dev server，观察输出结果：<br><img src="/img/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/Snabbdom/data%E6%9B%B4%E6%96%B0%E4%BD%8D%E7%BD%AE%E5%9C%A8update%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%87%8C.jpg" alt="data更新位置在update钩子函数里"><br>这下结果就很明显了，<strong>data 的更新位置在第三方模块传入的 update 钩子中！</strong></p><p>既然是第三方传入的，那不急着看传入的 update 钩子函数的内容；但我们得到了一个结论，<code>patchVnode</code>函数看起来只更新孩子节点或文本内容，是因为在开头的钩子函数中已经处理 data 的更新。<br>接下来就进入<code>updateChildren</code>函数，观察两个 vnode 都有孩子的情况下，真实 DOM 是怎么更新的</p><h4 id="updateChildren-函数——新旧-vnode-都有孩子的情况下更新真实-DOM"><a href="#updateChildren-函数——新旧-vnode-都有孩子的情况下更新真实-DOM" class="headerlink" title="updateChildren 函数——新旧 vnode 都有孩子的情况下更新真实 DOM"></a>updateChildren 函数——新旧 vnode 都有孩子的情况下更新真实 DOM</h4><p>为了更好的理解这个函数，我们把 sameVnode 的作用换一个更合适的说法：<strong>如果 sameVnode 的判断为真，就说明 oldVnode 指向的真实 DOM 不需要销毁，只需要改变内容，或者改变位置就可以了</strong></p><p>这个想法非常关键，因为 diff 的最小更新思路，就是通过<strong>尽量不删除真实 DOM</strong>实现的。</p><p>既然要真实 DOM 尽可能少销毁，那么平时在使用框架开发时，我们经常对表格的数据进行排序，这一过程就必然只涉及真实 DOM 节点的移动。而真实 DOM 节点的移动通过下面这个 DOM api 实现：<br><img src="/img/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/Snabbdom/insertBefore.jpg" alt="insertBefore"><br>这个函数接收两个真实 DOM 元素作为参数，调用的节点为父元素，第二个参数是这个父元素的孩子，函数的作用是把第一个参数的节点插入这个父元素中，并插入在第二个参数传入的孩子前，。但值得注意的是，选中的部分已经说明了，如果第一个参数已经存在父节点中，那么<strong>第一个参数传入的节点只会移动位置，而不会新建一个一样的节点</strong>。这就实现了我们需要的移动效果。</p><p>接下来，真正开始看这最核心部分的源码，思路过程都在注释里</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params"></span><br><span class="hljs-params">    parentElm: Node,</span><br><span class="hljs-params">    oldCh: VNode[],</span><br><span class="hljs-params">    newCh: VNode[],</span><br><span class="hljs-params">    insertedVnodeQueue: VNodeQueue</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-comment">// 这些指针都是指向当前未处理的节点！！</span><br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx];<br>    <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx];<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">oldKeyToIdx</span>: <span class="hljs-title class_">KeyToIndexMap</span> | <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">idxInOld</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">elmToMove</span>: <span class="hljs-title class_">VNode</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">before</span>: <span class="hljs-built_in">any</span>;<br><br>    <span class="hljs-comment">// 下面的循环体中的内容，实质上是找到所有可以复用的真实DOM节点（我们的目的就是尽可能复用，少删除少新建），更新他们的内容并插到合适的位置</span><br>    <span class="hljs-comment">// 如果旧的vnode的待处理节点指针相遇，说明现有的真实DOM已经处理完了，如果新的vnode指针还没相遇，剩下的孩子就都是必须新建真实DOM的了</span><br>    <span class="hljs-comment">// 如果新的vnode的待处理节点指针相遇，说明真实DOM的两侧已经是我们期待的样子了，中间的真实DOM也就是旧vnode待处理指针之间的，都是必须得删除的</span><br>    <span class="hljs-comment">// 上述两种情况，都是说明现有的可以复用的真实DOM已经更新复用完了，剩下多出来的必须要删除，缺少的就必须要新建</span><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>      <span class="hljs-comment">// 注意，这里用的不是===，而undefine == null是true</span><br>      <span class="hljs-keyword">if</span> (oldStartVnode == <span class="hljs-literal">null</span>) &#123;<br>        oldStartVnode = oldCh[++oldStartIdx]; <span class="hljs-comment">// Vnode might have been moved left</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndVnode == <span class="hljs-literal">null</span>) &#123;<br>        oldEndVnode = oldCh[--oldEndIdx];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartVnode == <span class="hljs-literal">null</span>) &#123;<br>        newStartVnode = newCh[++newStartIdx];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newEndVnode == <span class="hljs-literal">null</span>) &#123;<br>        newEndVnode = newCh[--newEndIdx];<br>      &#125;<br>      <span class="hljs-comment">// 下面开始处理，首先我们最希望的的肯定是真实DOM不用删除，也不用移动，就在当前位置更新就好</span><br>      <span class="hljs-comment">// 所以先看看左侧第一个真实DOM要不要删除或移动</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>        <span class="hljs-comment">// 左侧第一个真实DOM可以被复用！那么原地更新就好，当前节点处理完，左侧的待处理指针右移</span><br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue);<br>        oldStartVnode = oldCh[++oldStartIdx];<br>        newStartVnode = newCh[++newStartIdx];<br>      &#125;<br>      <span class="hljs-comment">// 很遗憾左侧第一个的真实DOM和新的虚拟DOM对不上，也就是说可能要被移动到其他地方或者被删除</span><br>      <span class="hljs-comment">// 那我们再从右侧判断，看看右侧第一个真实DOM要不要删除或移动</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>        <span class="hljs-comment">// 右侧第一个真实DOM可以被复用！那么原地更新就好，当前节点处理完，右侧的待处理指针左移</span><br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue);<br>        oldEndVnode = oldCh[--oldEndIdx];<br>        newEndVnode = newCh[--newEndIdx];<br>      &#125;<br>      <span class="hljs-comment">// 没办法，左右两侧的真实DOM都和我们期待的样子对不上</span><br>      <span class="hljs-comment">// 但还可能存在一种情况：</span><br>      <span class="hljs-comment">// 初始状态 A B C ...... X Y Z</span><br>      <span class="hljs-comment">// 目标状态 A B U ...... C Y Z</span><br>      <span class="hljs-comment">// 经过刚刚的两种最简单的判断，左侧的A B和右侧的Y Z都已经更新完</span><br>      <span class="hljs-comment">// 所以oldStartVnode指向C，oldEndVnode指向X，newStartVnode指向U，newEndVnode指向C</span><br>      <span class="hljs-comment">// 我们一眼就能看出来C只用换个位置，C插在oldEndVnode的后一项的前面（把X往前挤）就好了</span><br>      <span class="hljs-comment">// 下面的代码就是干这件事，看看有没有现在最左侧的真实DOM是可以直接移到右侧的</span><br>      <span class="hljs-comment">// 尽可能少循环，不考虑真实DOM的移动过程的话，这种判断的时间复杂度就是O(1)，</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123;<br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue);<br>        <span class="hljs-comment">// 移动到oldEndVnode的后一项的前面</span><br>        api.<span class="hljs-title function_">insertBefore</span>(<br>          parentElm,<br>          oldStartVnode.<span class="hljs-property">elm</span>!,<br>          api.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">elm</span>!)<br>        );<br>        <span class="hljs-comment">// 待处理的指针移动</span><br>        oldStartVnode = oldCh[++oldStartIdx];<br>        newEndVnode = newCh[--newEndIdx];<br>      &#125;<br>      <span class="hljs-comment">// 同理，和上面的不同方向罢了</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123;<br>        <span class="hljs-comment">// Vnode moved left</span><br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue);<br>        api.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">elm</span>!, oldStartVnode.<span class="hljs-property">elm</span>!);<br>        oldEndVnode = oldCh[--oldEndIdx];<br>        newStartVnode = newCh[++newStartIdx];<br>      &#125;<br>      <span class="hljs-comment">// 没办法了，当前真实DOM两端的节点都找不到能复用的位置</span><br>      <span class="hljs-comment">// 此时待处理指针两侧的真实DOM已经更新，排列成我们希望的样子了（和新的虚拟DOM一样）</span><br>      <span class="hljs-comment">// 那我们从新虚拟DOM待处理的最左侧节点入手，去循环找有没有 未被复用过，但现在可以拿来复用的真实DOM</span><br>      <span class="hljs-comment">// 如果有，拿来更新内容，插在oldStartVnode指向的真实DOM的前面就好了（因为新的虚拟DOM期待它在当前未处理的最左侧）</span><br>      <span class="hljs-comment">// 记得把被复用的这个真实DOM对应的oldVnode标记为已经复用过，设置成undefine就好了，经过上面undefnie == null的判断会被过滤掉</span><br>      <span class="hljs-comment">// 如果没有可以复用的真实DOM，只好新建了，还是插在oldStartVnode指向的真实DOM的前面</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这里判断是否可以复用，只与key、孩子的标签有关，都相同就可以复用</span><br>        <span class="hljs-keyword">if</span> (oldKeyToIdx === <span class="hljs-literal">undefined</span>) &#123;<br>          oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx);<br>        &#125;<br>        idxInOld = oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>];<br>        <span class="hljs-comment">// 没找到真实DOM中有相同的key，那没办法，新建吧</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123;<br>          <span class="hljs-comment">// New element</span><br>          api.<span class="hljs-title function_">insertBefore</span>(<br>            parentElm,<br>            <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue),<br>            oldStartVnode.<span class="hljs-property">elm</span>!<br>          );<br>        &#125;<br>        <span class="hljs-comment">// 有相同的key</span><br>        <span class="hljs-keyword">else</span> &#123;<br>          elmToMove = oldCh[idxInOld];<br>          <span class="hljs-comment">// 也要判断一下标签，标签相同才能复用真实DOM</span><br>          <span class="hljs-keyword">if</span> (elmToMove.<span class="hljs-property">sel</span> !== newStartVnode.<span class="hljs-property">sel</span>) &#123;<br>            api.<span class="hljs-title function_">insertBefore</span>(<br>              parentElm,<br>              <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue),<br>              oldStartVnode.<span class="hljs-property">elm</span>!<br>            );<br>          &#125;<br>          <span class="hljs-comment">// 终于可以复用了</span><br>          <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">patchVnode</span>(elmToMove, newStartVnode, insertedVnodeQueue);<br>            <span class="hljs-comment">// 真实DOM已经更新而且移动完了，那么对应的这个旧虚拟DOM应当被标记成处理完</span><br>            oldCh[idxInOld] = <span class="hljs-literal">undefined</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>            api.<span class="hljs-title function_">insertBefore</span>(parentElm, elmToMove.<span class="hljs-property">elm</span>!, oldStartVnode.<span class="hljs-property">elm</span>!);<br>          &#125;<br>        &#125;<br>        newStartVnode = newCh[++newStartIdx];<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 跳出循环咯，下面就是不得不新建的，或者是不得不删除的</span><br>    <span class="hljs-keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;<br>      before = newCh[newEndIdx + <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].<span class="hljs-property">elm</span>;<br>      <span class="hljs-title function_">addVnodes</span>(<br>        parentElm,<br>        before,<br>        newCh,<br>        newStartIdx,<br>        newEndIdx,<br>        insertedVnodeQueue<br>      );<br>    &#125;<br>    <span class="hljs-keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;<br>      <span class="hljs-title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx);<br>    &#125;<br>    <span class="hljs-comment">// 真实DOM更新完毕</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>看起来很复杂，但简单说就是双指针往中间扫描，尽可能不用移动真实 DOM；即使要移动，也尽可能不要循环，直接首尾两端交换；最后才不得不循环找能复用的真实 DOM。<br>这个函数走完，真实 DOM 就变成和新虚拟 DOM 一样的结构了，内容也都更新完毕，Snabbdom diff 算法完结撒花</p><h2 id="Snabbdom-完整源码带注释"><a href="#Snabbdom-完整源码带注释" class="headerlink" title="Snabbdom 完整源码带注释"></a>Snabbdom 完整源码带注释</h2><p><a href="/static/Snabbdom%E6%BA%90%E7%A0%81ts%E5%8A%A0%E6%B3%A8%E9%87%8A%E7%89%88.rar">Snabbdom 完整源码带注释</a></p><h1 id="虚拟-DOM-的优缺点"><a href="#虚拟-DOM-的优缺点" class="headerlink" title="虚拟 DOM 的优缺点"></a>虚拟 DOM 的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM： 不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，以可预期的方式更新视图，极大提高开发效率；</li><li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化；</li><li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack简易笔记</title>
    <link href="/2023/03/13/webpack%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/13/webpack%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>持续更新中<br>不得不说上班摸鱼是一件快乐的事情</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>众所周知，vue-cli 和 create-react-app 都是内置 webpack 进行打包<br>那么这个这么重要的东西是什么，官网是这样定义的</p><blockquote><p>webpack 是一个用于现代 JavaScript 应用程序的 <em>静态模块</em>打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="bundles 是 webpack 打包后生成的文件，它们包含了经过加载和编译的源代码。一个 bundle 可以由一个或多个模块（module）组成，模块是 webpack 处理项目中的不同类型的文件的基本单位。">[1]</span></a></sup>，它们均为静态资源，用于展示你的内容。</p></blockquote><p>（好的，看到官网这种不说人话的风格是真的发晕，也就贴上来镇场子）</p><h2 id="为什么使用-webpack"><a href="#为什么使用-webpack" class="headerlink" title="为什么使用 webpack"></a>为什么使用 webpack</h2><p>首先，模块化开发是历史的趋势，不解释<br>那模块化开发，总得引入模块呀，所以随着不同模块化规范的出现，引入模块的语法也出现了好几种，最常见的两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScipt">// CommonJS<br>const path = require(&#x27;path&#x27;)<br><br>// ES6<br>import Vue from &#x27;vue&#x27;<br></code></pre></td></tr></table></figure><p>那分成了不同模块，运行代码的时候得有人做类似编译链接的事情呀，不然鬼知道依赖树有多高有多大<br>所以构建工具就成了必不可少的了，webpack 就是其中之一<br>加上对于模块化开发来说有个坏消息，就是上面这些引入模块的语法刚面世的时候浏览器不双标，几乎一视同仁的不支持<br>所以构建工具还得肩负起把这些高级语法转换成 ES5 语法，这才能让浏览器执行。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>稍微详细点说，webpac 打包的时候做了这些事:</p><ul><li>解析入口文件</li><li>递归分析依赖，生成抽象语法树</li><li>根据入口和依赖模块生成 chunk（有点类似手动的分包，打包完后这些 chunk 是可以按需下载，也可以并行下载加快加载速度）</li><li>把每个模块进行转换，这里的模块除了 js 还包含 css、图片等等，但 webpack 本身是只认识 js 和 json 的，所以在这一步中,webpack 会按顺序链式调用所有配置好的 Loader 对模块进行处理。此外这一步还包括把 js 转译成 ES5 语法，对代码进行压缩等等</li><li>对每个 chunk 进行优化、整合、拆分、去重等操作，生成最终的资源文件（assets）</li><li>输出资源文件到指定的目录中</li></ul><p>然后就得到熟悉的 dist 目录啦<br>但是为什么上面的全是抽象的名词捏，还是需要更详细点的过程解析（晕）</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>bundles 是 webpack 打包后生成的文件，它们包含了经过加载和编译的源代码。一个 bundle 可以由一个或多个模块（module）组成，模块是 webpack 处理项目中的不同类型的文件的基本单位。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite模块化加载store和接口</title>
    <link href="/2023/03/11/vite%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDstore%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/03/11/vite%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDstore%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在过去的实习和项目开发经历中，规范的大项目都是使用 vue2，因此习惯了使用 webpack 的 require.context 批量导入模块。<br>但最近学习使用 vite + taildwindcss 进行开发时想起来 vite 没有这个接口，因此找办法代替</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/img/vite%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDstore%E5%92%8C%E6%8E%A5%E5%8F%A3/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg" alt="store缓存文件结构"></p><h2 id="webpack-写法"><a href="#webpack-写法" class="headerlink" title="webpack 写法"></a>webpack 写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">devtools</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 打开vue调试工具</span><br><span class="hljs-keyword">const</span> files = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&#x27;./modules&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.js$/</span>)<br><span class="hljs-keyword">const</span> modules = &#123;&#125;<br><br>files.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>  modules[key.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\.\/|\.js)/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)] = <span class="hljs-title function_">files</span>(key).<span class="hljs-property">default</span><br>&#125;)<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(modules).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>  modules[key][<span class="hljs-string">&#x27;namespaced&#x27;</span>] = <span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  modules<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure><h2 id="vite-写法"><a href="#vite-写法" class="headerlink" title="vite 写法"></a>vite 写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">const</span> routeFiles = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">globEager</span>(<span class="hljs-string">&#x27;@/store/modules/*.js&#x27;</span>)<br><br><span class="hljs-keyword">const</span> modules = &#123;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> path <span class="hljs-keyword">in</span> routeFiles) &#123;<br>  <span class="hljs-keyword">const</span> key = path.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\/src\/store\/modules\/(.*?).js/</span>)[<span class="hljs-number">1</span>]<br>  modules[key] = routeFiles[path].<span class="hljs-property">default</span><br>  modules[key][<span class="hljs-string">&#x27;namespaced&#x27;</span>] = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>  modules<br>&#125;)<br></code></pre></td></tr></table></figure><p>问题解决</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot实现数据库读写分离</title>
    <link href="/2023/03/11/Springboot%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <url>/2023/03/11/Springboot%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于 shardingsphere 官方文档的<a href="https://shardingsphere.apache.org/document/current/cn/quick-start/shardingsphere-jdbc-quick-start/">配置参考</a>用了报错，网上的也基本用不了，于是参考其他博客，通过 aop 手动更改数据源。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.modb.pro/db/155331">第一篇</a><br><a href="https://www.cnblogs.com/wuyoucao/p/10965903.html">第二篇</a><br>前置操作：配置好 mysql 的读写分离</p><h2 id="Springboot-yml-配置文件-部分"><a href="#Springboot-yml-配置文件-部分" class="headerlink" title="Springboot yml 配置文件(部分)"></a>Springboot yml 配置文件(部分)</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">master:</span><br>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">jdbc-url:</span> <span class="hljs-string">主数据库链接</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">用户</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">密码</span><br>    <span class="hljs-attr">slave0:</span><br>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">jdbc-url:</span> <span class="hljs-string">从数据库链接</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">用户</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">密码</span><br>    <span class="hljs-string">其他从数据库:</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>配置了多个数据源，因此需要一个配置类，设置当前使用哪个数据源。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>先创建一个枚举类，作为数据源的 key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DBTypeEnum</span> &#123;<br>    MASTER, SLAVE0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据源配置类"><a href="#数据源配置类" class="headerlink" title="数据源配置类"></a>数据源配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConfigurationProperties(&quot;spring.datasource.master&quot;)</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">masterDataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConfigurationProperties(&quot;spring.datasource.slave0&quot;)</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">slave0DataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> DataSourceBuilder.create().build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">myRoutingDataSource</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource,</span><br><span class="hljs-params">                                          <span class="hljs-meta">@Qualifier(&quot;slave0DataSource&quot;)</span> DataSource slave0DataSource)</span> &#123;<br>        <span class="hljs-comment">// 把所有数据源放入map中待更换</span><br>        HashMap&lt;Object, Object&gt; targetDataSources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        targetDataSources.put(DBTypeEnum.MASTER, masterDataSource);<br>        targetDataSources.put(DBTypeEnum.SLAVE0, slave0DataSource);<br><br>        <span class="hljs-type">MyRoutingDataSource</span> <span class="hljs-variable">myRoutingDataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRoutingDataSource</span>();<br>        <span class="hljs-comment">// 设置默认数据源</span><br>        myRoutingDataSource.setDefaultTargetDataSource(masterDataSource);<br>        myRoutingDataSource.setTargetDataSources(targetDataSources);<br>        <span class="hljs-keyword">return</span> myRoutingDataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mybatis-配置类"><a href="#mybatis-配置类" class="headerlink" title="mybatis 配置类"></a>mybatis 配置类</h2><p>配置 mybatis，使用 myRoutingDataSource 这个数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableTransactionManagement(order = 10)</span> <span class="hljs-comment">// 设置事务优先级，这很重要！！</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisConfig</span> &#123;<br>    <span class="hljs-meta">@Resource(name = &quot;myRoutingDataSource&quot;)</span><br>    <span class="hljs-keyword">private</span> DataSource myRoutingDataSource;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">sqlSessionFactoryBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>        sqlSessionFactoryBean.setDataSource(myRoutingDataSource);<br>        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">platformTransactionManager</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(myRoutingDataSource);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="把数据源配置到线程上下文中"><a href="#把数据源配置到线程上下文中" class="headerlink" title="把数据源配置到线程上下文中"></a>把数据源配置到线程上下文中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBContextHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;DBTypeEnum&gt; contextHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DBTypeEnum <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (contextHolder.get() == <span class="hljs-literal">null</span>)<br>            contextHolder.set(DBTypeEnum.MASTER);<br>        <span class="hljs-keyword">return</span> contextHolder.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">master</span><span class="hljs-params">()</span> &#123;<br>        contextHolder.set(DBTypeEnum.MASTER);<br>        System.out.println(<span class="hljs-string">&quot;切换到master&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">slave</span><span class="hljs-params">()</span> &#123;<br>        contextHolder.set(DBTypeEnum.SLAVE0);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重写-determineCurrentLookupKey-切换数据源"><a href="#重写-determineCurrentLookupKey-切换数据源" class="headerlink" title="重写 determineCurrentLookupKey 切换数据源"></a>重写 determineCurrentLookupKey 切换数据源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> DBContextHolder.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>最后，通过 aop，在每次执行 mybatis 的前判断 sql 类型，读操作分配从数据库，写操作分配到主数据库。<br>根据参考博客，有可能存在必须从主库读的情况，因此加一个注解表示强制从主库读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceAop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;!@annotation(com.wolf1024hzx.annotation.Master) &quot; +</span><br><span class="hljs-meta">            &quot;|| execution(* com.wolf1024hzx.service..*.get*(..)))</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">    public void readPointcut() &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    @Pointcut(&quot;</span><span class="hljs-meta">@annotation(com.wolf1024hzx.annotation.Master)</span> <span class="hljs-string">&quot; +</span><br><span class="hljs-string">            &quot;</span>|| execution(* com.wolf1024hzx.service..*.create*(..)) <span class="hljs-string">&quot; +</span><br><span class="hljs-string">            &quot;</span>|| execution(* com.wolf1024hzx.service..*.update*(..)) <span class="hljs-string">&quot; +</span><br><span class="hljs-string">            &quot;</span>|| execution(* com.wolf1024hzx.service..*.delete*(..)) <span class="hljs-string">&quot;)</span><br><span class="hljs-string">    public void writePointcut() &#123;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    @Before(&quot;</span>readPointcut()<span class="hljs-string">&quot;)</span><br><span class="hljs-string">    public void read() &#123;</span><br><span class="hljs-string">        DBContextHolder.slave();</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    @Before(&quot;</span>writePointcut()<span class="hljs-string">&quot;)</span><br><span class="hljs-string">    public void write() &#123;</span><br><span class="hljs-string">        DBContextHolder.master();</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    @Override</span><br><span class="hljs-string">    public int getOrder() &#123;</span><br><span class="hljs-string">        return 0;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>注意这里重写了 getOrder 方法，这是因为按照第一篇博客的配置，会发现服务器的执行顺序是 springboot 拿到数据源-&gt;尝试执行 sql-&gt;aop-&gt;执行 sql，这样一来 aop 改变数据源就没有效果，全是从主机读写。因此需要把数据库事务的优先级调低，把 aop 操作的优先级调高，确保数据源被成功切换。<br>可以通过数据库通用查询日志（general_log）观察读写分离是否成功。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
