[{"title":"虚拟DOM学习","url":"/2023/03/18/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/","content":"虚拟 DOM 介绍早期 Web 开发中，视图改变都需要程序员手动修改 DOM。直到 jQuery 的时代，DOM 操作有了极大的简化，但仍然需要我们频繁操作 DOM 实现页面效果和交互。\n随着数据驱动视图思想的出现，Vue 和 React 两大开发框架面世，提出了一个新的概念——虚拟 DOM。虚拟 DOM 是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点。数据改变后，通过修改这个对象，然后把它与真实 DOM 进行比较，最后仅修改必要的 DOM 节点，就能完成视图更新。而这个 DOM 比较的算法就是 diff 算法。在不同开发框架，同一开发框架的不同版本中，diff 算法都有不同实现，diff 算法发生在虚拟 DOM 上。\n虚拟 DOM 对象举例&lt;!-- 真实DOM --&gt;&lt;div class=&quot;box&quot;&gt;  &lt;h1&gt;标题&lt;/h1&gt;  &lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;\n\n/* 虚拟DOM */&#123;  sel: &#x27;div&#x27;,  data: &#123;    class: &#123; box: true &#125;  &#125;,  children: [    &#123; sel: &#x27;h1&#x27;, data: &#123;&#125;, text: &#x27;标题&#x27; &#125;,    &#123;      sel: &#x27;ul&#x27;,      data: &#123;&#125;,      children: [        &#123; sel: &#x27;li&#x27;, data: &#123;&#125;, text: &#x27;列表项1&#x27; &#125;,        &#123; sel: &#x27;li&#x27;, data: &#123;&#125;, text: &#x27;列表项2&#x27; &#125;      ]    &#125;  ]&#125;\n\ndiff 算法的起始——SnabbdomSnabbdom 项目 Github 地址\nSnabbdom 是一个虚拟 DOM 库，其核心代码只有约 200 行。下面先跑通 Snabbdom 的官方样例代码。\nSnabbdom 样例代码先搭建运行环境。作为一个虚拟 DOM 库，当然不能运行在 nodejs 环境，因此先搭建 webpack-dev-server。\n初始化项目，并安装依赖\nnpm initnpm i -D snabbdomnpm i --legacy-peer-deps -D webpack@5 webpack-cli@3 webpack-dev-server@3\n\n配置 webpack.config.js\n/* webpack.config.js */const path = require(&#x27;path&#x27;);module.exports = &#123;  mode: &#x27;development&#x27;,  entry: &#x27;./src/index.js&#x27;,  output: &#123;    publicPath: &#x27;fake&#x27;,    filename: &#x27;bundle.js&#x27;,  &#125;,  devServer: &#123;    port: 8080,    contentBase: &#x27;www&#x27;  &#125;&#125;;\n\n创建 src 和 www 目录，分别创建 index.js 和 html 文件后，此时项目目录结构如下：\n复制 Snabbdom 官方样例代码到 index.js 中\n/* src/index.js */import &#123;  init,  classModule,  propsModule,  styleModule,  eventListenersModule,  h,&#125; from &quot;snabbdom&quot;const patch = init([  // 通过传入模块初始化 patch 函数  classModule, // 开启 classes 功能  propsModule, // 支持传入 props  styleModule, // 支持内联样式同时支持动画  eventListenersModule, // 添加事件监听])const container = document.getElementById(&quot;container&quot;)const vnode = h(&quot;div#container.two.classes&quot;, &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;, [  h(&quot;span&quot;, &#123; style: &#123; fontWeight: &quot;bold&quot; &#125; &#125;, &quot;This is bold&quot;),  &quot; and this is just normal text&quot;,  h(&quot;a&quot;, &#123; props: &#123; href: &quot;/foo&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),])// 传入一个空的元素节点 - 将产生副作用（修改该节点）patch(container, vnode)const newVnode = h(  &quot;div#container.two.classes&quot;,  &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;,  [    h(      &quot;span&quot;,      &#123; style: &#123; fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot; &#125; &#125;,      &quot;This is now italic type&quot;    ),    &quot; and this is still just normal text&quot;,    h(&quot;a&quot;, &#123; props: &#123; href: &quot;/bar&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),  ])// 再次调用 `patch`patch(vnode, newVnode) // 将旧节点更新为新节点\n\n观察代码可知，需要一个 id 为 container 的 div。因此在 index.html 中创建该 div 元素，并用 script 标签引入 webpack 打包后的虚拟 bundle.js 文件\n&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;  &lt;script src=&quot;/fake/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;\n\n在 package.json 中配置好 dev 脚本\n/* package.json部分 */&#123;  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;webpack-dev-server&quot;  &#125;&#125;\n\nnpm run dev 运行该脚本，即可访问 http://localhost:8080 观察样例代码运行结果\n\n样例代码研究再贴一次样例代码方便观察\n/* src/index.js */import &#123;  init,  classModule,  propsModule,  styleModule,  eventListenersModule,  h,&#125; from &quot;snabbdom&quot;const patch = init([  // 通过传入模块初始化 patch 函数  classModule, // 开启 classes 功能  propsModule, // 支持传入 props  styleModule, // 支持内联样式同时支持动画  eventListenersModule, // 添加事件监听])const container = document.getElementById(&quot;container&quot;)const vnode = h(&quot;div#container.two.classes&quot;, &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;, [  h(&quot;span&quot;, &#123; style: &#123; fontWeight: &quot;bold&quot; &#125; &#125;, &quot;This is bold&quot;),  &quot; and this is just normal text&quot;,  h(&quot;a&quot;, &#123; props: &#123; href: &quot;/foo&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),])// 传入一个空的元素节点 - 将产生副作用（修改该节点）patch(container, vnode)const newVnode = h(  &quot;div#container.two.classes&quot;,  &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;,  [    h(      &quot;span&quot;,      &#123; style: &#123; fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot; &#125; &#125;,      &quot;This is now italic type&quot;    ),    &quot; and this is still just normal text&quot;,    h(&quot;a&quot;, &#123; props: &#123; href: &quot;/bar&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),  ])// 再次调用 `patch`patch(vnode, newVnode) // 将旧节点更新为新节点\n\n首先不难猜出，h 函数的作用就是创建一个虚拟 DOM 节点，下面点进 h 函数阅读 ts 源码（已加上注释）\nh 函数——用于创建虚拟节点export function h(sel: any, b?: any, c?: any): VNode &#123;  let data: VNodeData = &#123;&#125;;  let children: any;  let text: any;  let i: number;  if (c !== undefined) &#123;    /* data就是class等属性 */    if (b !== null) &#123;      data = b;    &#125;    /* 参数c是一个数组，则数组内部每一项都是虚拟DOM对象，都是这个节点的孩子 */    if (is.array(c)) &#123;      children = c;    &#125;    /* 参数c是string或number，则这个节点里的文本内容就是参数c */    else if (is.primitive(c)) &#123;      text = c.toString();    &#125;    /* 根据c的sel属性存在，可以得知参数c也是一个虚拟DOM对象 */    else if (c &amp;&amp; c.sel) &#123;      children = [c];    &#125;  &#125;  /* 只有两个参数，没有c，进行一样的判断 */  else if (b !== undefined &amp;&amp; b !== null) &#123;    if (is.array(b)) &#123;      children = b;    &#125; else if (is.primitive(b)) &#123;      text = b.toString();    &#125; else if (b &amp;&amp; b.sel) &#123;      children = [b];    &#125; else &#123;      data = b;    &#125;  &#125;  if (children !== undefined) &#123;    for (i = 0; i &lt; children.length; ++i) &#123;      /* 如果children中的某一项不是一个对象，只是一个string或number，那么生成一个虚拟DOM包裹这个文本内容 */      if (is.primitive(children[i]))        children[i] = vnode(          undefined, /* sel */          undefined, /* data */          undefined, /* children */          children[i], /* text */          undefined /* elm */        );    &#125;  &#125;  if (    sel[0] === &quot;s&quot; &amp;&amp;    sel[1] === &quot;v&quot; &amp;&amp;    sel[2] === &quot;g&quot; &amp;&amp;    (sel.length === 3 || sel[3] === &quot;.&quot; || sel[3] === &quot;#&quot;)  ) &#123;    addNS(data, children, sel);  &#125;  return vnode(sel, data, children, text, undefined);&#125;\n\n这个函数还是相当好理解的，根据参数的类型和数量，返回一个 VNode 类型的对象（vnode 函数返回 new 出来的），也就是一个虚拟 DOM 节点\nh 函数的返回值——VNode 对象既然 h 函数返回的是一个 VNode 对象，那接下来看看这个类是个什么东西\nexport type Key = string | number | symbol;export interface VNode &#123;  sel: string | undefined;                      // selector，选择器，DOM节点的标签  data: VNodeData | undefined;                  // 节点属性，详细定义见下面VNodeData  children: Array&lt;VNode | string&gt; | undefined;  // 子结点  elm: Node | undefined;                        // 剧透，这个属性是对应的真实DOM节点，undefined表示这个虚拟节点未上树  text: string | undefined;                     // 节点内部  key: Key | undefined;                         // 节点唯一标识，Vue里的key就是这个东西啦&#125;export interface VNodeData &#123;  props?: Props;  attrs?: Attrs;  class?: Classes;  style?: VNodeStyle;  dataset?: Dataset;  on?: On;  attachData?: AttachData;  hook?: Hooks;  key?: Key;  ns?: string; // for SVGs  fn?: () =&gt; VNode; // for thunks  args?: any[]; // for thunks  is?: string; // for custom elements v1  [key: string]: any; // for any other 3rd party module&#125;\n\n这下虚拟 DOM 节点对象的结构就非常清楚了，但还有个小小的问题，props 和 attrs 的区别是什么呢？可以学习这 2 篇博客：\n\nDOM 中 property 和 attribute 详解 1\nDOM 中 property 和 attribute 详解 2\n\n简单的总结一下就是，这两者的区分没有什么规则，但有一定规律，并且props是DOM元素初始化时自带的一些属性\n未完待续虚拟 DOM 的优缺点优点\n保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；\n无需手动操作 DOM： 不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，以可预期的方式更新视图，极大提高开发效率；\n跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。\n\n缺点\n无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化；\n首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。\n\n","categories":[],"tags":["前端"]},{"title":"webpack简易笔记","url":"/2023/03/13/webpack%E5%AD%A6%E4%B9%A0/","content":"持续更新中不得不说上班摸鱼是一件快乐的事情\n开始众所周知，vue-cli 和 create-react-app 都是内置 webpack 进行打包那么这个这么重要的东西是什么，官网是这样定义的\n\nwebpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles[^1]，它们均为静态资源，用于展示你的内容。\n\n（好的，看到官网这种不说人话的风格是真的发晕，也就贴上来镇场子）\n[^1]: bundles 是 webpack 打包后生成的文件，它们包含了经过加载和编译的源代码。一个 bundle 可以由一个或多个模块（module）组成，模块是 webpack 处理项目中的不同类型的文件的基本单位。\n为什么使用 webpack首先，模块化开发是历史的趋势，不解释那模块化开发，总得引入模块呀，所以随着不同模块化规范的出现，引入模块的语法也出现了好几种，最常见的两个：\n// CommonJSconst path = require(&#x27;path&#x27;)// ES6import Vue from &#x27;vue&#x27;\n\n那分成了不同模块，运行代码的时候得有人做类似编译链接的事情呀，不然鬼知道依赖树有多高有多大所以构建工具就成了必不可少的了，webpack 就是其中之一加上对于模块化开发来说有个坏消息，就是上面这些引入模块的语法刚面世的时候浏览器不双标，几乎一视同仁的不支持所以构建工具还得肩负起把这些高级语法转换成 ES5 语法，这才能让浏览器执行。\n入门稍微详细点说，webpac 打包的时候做了这些事:\n\n解析入口文件\n递归分析依赖，生成抽象语法树\n根据入口和依赖模块生成 chunk（有点类似手动的分包，打包完后这些 chunk 是可以按需下载，也可以并行下载加快加载速度）\n把每个模块进行转换，这里的模块除了 js 还包含 css、图片等等，但 webpack 本身是只认识 js 和 json 的，所以在这一步中,webpack 会按顺序链式调用所有配置好的 Loader 对模块进行处理。此外这一步还包括把 js 转译成 ES5 语法，对代码进行压缩等等\n对每个 chunk 进行优化、整合、拆分、去重等操作，生成最终的资源文件（assets）\n输出资源文件到指定的目录中\n\n然后就得到熟悉的 dist 目录啦但是为什么上面的全是抽象的名词捏，还是需要更详细点的过程解析（晕）\n","categories":["学习"],"tags":["前端"]},{"title":"vite模块化加载store和接口","url":"/2023/03/11/vite%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDstore%E5%92%8C%E6%8E%A5%E5%8F%A3/","content":"问题描述在过去的实习和项目开发经历中，规范的大项目都是使用 vue2，因此习惯了使用 webpack 的 require.context 批量导入模块。但最近学习使用 vite + taildwindcss 进行开发时想起来 vite 没有这个接口，因此找办法代替\n目录结构\nwebpack 写法// index.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)Vue.config.devtools = true; // 打开vue调试工具const files = require.context(&#x27;./modules&#x27;, false, /\\.js$/)const modules = &#123;&#125;files.keys().forEach((key) =&gt; &#123;  modules[key.replace(/(\\.\\/|\\.js)/g, &#x27;&#x27;)] = files(key).default&#125;)Object.keys(modules).forEach((key) =&gt; &#123;  modules[key][&#x27;namespaced&#x27;] = true&#125;)const store = new Vuex.Store(&#123;  modules&#125;)export default store\n\nvite 写法// index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;const routeFiles = import.meta.globEager(&#x27;@/store/modules/*.js&#x27;)const modules = &#123;&#125;for (const path in routeFiles) &#123;  const key = path.match(/\\/src\\/store\\/modules\\/(.*?).js/)[1]  modules[key] = routeFiles[path].default  modules[key][&#x27;namespaced&#x27;] = true&#125;export default createStore(&#123;  modules&#125;)\n\n问题解决\n","categories":["学习"],"tags":["前端"]},{"title":"Springboot实现数据库读写分离","url":"/2023/03/11/Springboot%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/","content":"前言由于 shardingsphere 官方文档的配置参考用了报错，网上的也基本用不了，于是参考其他博客，通过 aop 手动更改数据源。\n参考博客第一篇第二篇前置操作：配置好 mysql 的读写分离\nSpringboot yml 配置文件(部分)spring:  datasource:    master:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 主数据库链接      username: 用户      password: 密码    slave0:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 从数据库链接      username: 用户      password: 密码    其他从数据库: ...\n\n配置了多个数据源，因此需要一个配置类，设置当前使用哪个数据源。\n枚举类先创建一个枚举类，作为数据源的 key\npublic enum DBTypeEnum &#123;    MASTER, SLAVE0;&#125;\n\n数据源配置类@Configurationpublic class DataSourceConfig &#123;    @Bean    @ConfigurationProperties(&quot;spring.datasource.master&quot;)    public DataSource masterDataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    @ConfigurationProperties(&quot;spring.datasource.slave0&quot;)    public DataSource slave0DataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    public DataSource myRoutingDataSource(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource,                                          @Qualifier(&quot;slave0DataSource&quot;) DataSource slave0DataSource) &#123;        // 把所有数据源放入map中待更换        HashMap&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();        targetDataSources.put(DBTypeEnum.MASTER, masterDataSource);        targetDataSources.put(DBTypeEnum.SLAVE0, slave0DataSource);        MyRoutingDataSource myRoutingDataSource = new MyRoutingDataSource();        // 设置默认数据源        myRoutingDataSource.setDefaultTargetDataSource(masterDataSource);        myRoutingDataSource.setTargetDataSources(targetDataSources);        return myRoutingDataSource;    &#125;&#125;\n\nmybatis 配置类配置 mybatis，使用 myRoutingDataSource 这个数据源\n@EnableTransactionManagement(order = 10) // 设置事务优先级，这很重要！！@Configurationpublic class MyBatisConfig &#123;    @Resource(name = &quot;myRoutingDataSource&quot;)    private DataSource myRoutingDataSource;    @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception &#123;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(myRoutingDataSource);        return sqlSessionFactoryBean.getObject();    &#125;    @Bean    public PlatformTransactionManager platformTransactionManager() &#123;        return new DataSourceTransactionManager(myRoutingDataSource);    &#125;&#125;\n\n把数据源配置到线程上下文中public class DBContextHolder &#123;    private static final ThreadLocal&lt;DBTypeEnum&gt; contextHolder = new ThreadLocal&lt;&gt;();    public static DBTypeEnum get() &#123;        if (contextHolder.get() == null)            contextHolder.set(DBTypeEnum.MASTER);        return contextHolder.get();    &#125;    public static void master() &#123;        contextHolder.set(DBTypeEnum.MASTER);        System.out.println(&quot;切换到master&quot;);    &#125;    public static void slave() &#123;        contextHolder.set(DBTypeEnum.SLAVE0);    &#125;&#125;\n\n重写 determineCurrentLookupKey 切换数据源public class MyRoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        return DBContextHolder.get();    &#125;&#125;\n\nAOP最后，通过 aop，在每次执行 mybatis 的前判断 sql 类型，读操作分配从数据库，写操作分配到主数据库。根据参考博客，有可能存在必须从主库读的情况，因此加一个注解表示强制从主库读：\n@Aspect@Componentpublic class DataSourceAop implements Ordered &#123;    @Pointcut(&quot;!@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.get*(..)))&quot;)    public void readPointcut() &#123;    &#125;    @Pointcut(&quot;@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.create*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.update*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.delete*(..)) &quot;)    public void writePointcut() &#123;    &#125;    @Before(&quot;readPointcut()&quot;)    public void read() &#123;        DBContextHolder.slave();    &#125;    @Before(&quot;writePointcut()&quot;)    public void write() &#123;        DBContextHolder.master();    &#125;    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;\n\n注意这里重写了 getOrder 方法，这是因为按照第一篇博客的配置，会发现服务器的执行顺序是 springboot 拿到数据源-&gt;尝试执行 sql-&gt;aop-&gt;执行 sql，这样一来 aop 改变数据源就没有效果，全是从主机读写。因此需要把数据库事务的优先级调低，把 aop 操作的优先级调高，确保数据源被成功切换。可以通过数据库通用查询日志（general_log）观察读写分离是否成功。\n","categories":["学习"],"tags":["后端","数据库"]},{"title":"Hello World","url":"/2023/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["其他"],"tags":["其他"]}]