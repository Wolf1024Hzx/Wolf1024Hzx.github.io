[{"title":"虚拟DOM学习","url":"/2023/03/20/%E8%99%9A%E6%8B%9FDOM%E5%AD%A6%E4%B9%A0/","content":"虚拟 DOM 介绍早期 Web 开发中，视图改变都需要程序员手动修改 DOM。直到 jQuery 的时代，DOM 操作有了极大的简化，但仍然需要我们频繁操作 DOM 实现页面效果和交互。\n随着数据驱动视图思想的出现，Vue 和 React 两大开发框架面世，提出了一个新的概念——虚拟 DOM。虚拟 DOM 是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点。数据改变后，通过修改这个对象，然后把它与真实 DOM 进行比较，最后仅修改必要的 DOM 节点，就能完成视图更新。而这个 DOM 比较的算法就是 diff 算法。在不同开发框架，同一开发框架的不同版本中，diff 算法都有不同实现，diff 算法发生在虚拟 DOM 上。\n虚拟 DOM 对象举例&lt;!-- 真实DOM --&gt;&lt;div class=&quot;box&quot;&gt;  &lt;h1&gt;标题&lt;/h1&gt;  &lt;ul&gt;    &lt;li&gt;列表项1&lt;/li&gt;    &lt;li&gt;列表项2&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;\n\n/* 虚拟DOM */&#123;  sel: &#x27;div&#x27;,  data: &#123;    class: &#123; box: true &#125;  &#125;,  children: [    &#123; sel: &#x27;h1&#x27;, data: &#123;&#125;, text: &#x27;标题&#x27; &#125;,    &#123;      sel: &#x27;ul&#x27;,      data: &#123;&#125;,      children: [        &#123; sel: &#x27;li&#x27;, data: &#123;&#125;, text: &#x27;列表项1&#x27; &#125;,        &#123; sel: &#x27;li&#x27;, data: &#123;&#125;, text: &#x27;列表项2&#x27; &#125;      ]    &#125;  ]&#125;\n\ndiff 算法的起始——SnabbdomSnabbdom 项目 Github 地址\nSnabbdom 是一个虚拟 DOM 库，其核心代码只有约 200 行。下面先跑通 Snabbdom 的官方样例代码。\nSnabbdom 样例代码先搭建运行环境。作为一个虚拟 DOM 库，当然不能运行在 nodejs 环境，因此先搭建 webpack-dev-server。\n初始化项目，并安装依赖\nnpm initnpm i -D snabbdomnpm i --legacy-peer-deps -D webpack@5 webpack-cli@3 webpack-dev-server@3\n\n配置 webpack.config.js\n/* webpack.config.js */const path = require(&#x27;path&#x27;);module.exports = &#123;  mode: &#x27;development&#x27;,  entry: &#x27;./src/index.js&#x27;,  output: &#123;    publicPath: &#x27;fake&#x27;,    filename: &#x27;bundle.js&#x27;,  &#125;,  devServer: &#123;    port: 8080,    contentBase: &#x27;www&#x27;  &#125;&#125;;\n\n创建 src 和 www 目录，分别创建 index.js 和 html 文件后，此时项目目录结构如下：\n复制 Snabbdom 官方样例代码到 index.js 中\n/* src/index.js */import &#123;  init,  classModule,  propsModule,  styleModule,  eventListenersModule,  h,&#125; from &quot;snabbdom&quot;const patch = init([  // 通过传入模块初始化 patch 函数  classModule, // 开启 classes 功能  propsModule, // 支持传入 props  styleModule, // 支持内联样式同时支持动画  eventListenersModule, // 添加事件监听])const container = document.getElementById(&quot;container&quot;)const vnode = h(&quot;div#container.two.classes&quot;, &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;, [  h(&quot;span&quot;, &#123; style: &#123; fontWeight: &quot;bold&quot; &#125; &#125;, &quot;This is bold&quot;),  &quot; and this is just normal text&quot;,  h(&quot;a&quot;, &#123; props: &#123; href: &quot;/foo&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),])// 传入一个空的元素节点 - 将产生副作用（修改该节点）patch(container, vnode)const newVnode = h(  &quot;div#container.two.classes&quot;,  &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;,  [    h(      &quot;span&quot;,      &#123; style: &#123; fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot; &#125; &#125;,      &quot;This is now italic type&quot;    ),    &quot; and this is still just normal text&quot;,    h(&quot;a&quot;, &#123; props: &#123; href: &quot;/bar&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),  ])// 再次调用 `patch`patch(vnode, newVnode) // 将旧节点更新为新节点\n\n观察代码可知，需要一个 id 为 container 的 div。因此在 index.html 中创建该 div 元素，并用 script 标签引入 webpack 打包后的虚拟 bundle.js 文件\n&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;  &lt;script src=&quot;/fake/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;\n\n在 package.json 中配置好 dev 脚本\n/* package.json部分 */&#123;  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,    &quot;dev&quot;: &quot;webpack-dev-server&quot;  &#125;&#125;\n\nnpm run dev 运行该脚本，即可访问 http://localhost:8080 观察样例代码运行结果\n\n样例代码研究再贴一次样例代码方便观察\n/* src/index.js */import &#123;  init,  classModule,  propsModule,  styleModule,  eventListenersModule,  h,&#125; from &quot;snabbdom&quot;const patch = init([  // 通过传入模块初始化 patch 函数  classModule, // 开启 classes 功能  propsModule, // 支持传入 props  styleModule, // 支持内联样式同时支持动画  eventListenersModule, // 添加事件监听])const container = document.getElementById(&quot;container&quot;)const vnode = h(&quot;div#container.two.classes&quot;, &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;, [  h(&quot;span&quot;, &#123; style: &#123; fontWeight: &quot;bold&quot; &#125; &#125;, &quot;This is bold&quot;),  &quot; and this is just normal text&quot;,  h(&quot;a&quot;, &#123; props: &#123; href: &quot;/foo&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),])// 传入一个空的元素节点 - 将产生副作用（修改该节点）patch(container, vnode)const newVnode = h(  &quot;div#container.two.classes&quot;,  &#123; on: &#123; click: () =&gt; &#123;&#125; &#125; &#125;,  [    h(      &quot;span&quot;,      &#123; style: &#123; fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot; &#125; &#125;,      &quot;This is now italic type&quot;    ),    &quot; and this is still just normal text&quot;,    h(&quot;a&quot;, &#123; props: &#123; href: &quot;/bar&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),  ])// 再次调用 `patch`patch(vnode, newVnode) // 将旧节点更新为新节点\n\n首先不难猜出，h 函数的作用就是创建一个虚拟 DOM 节点，下面点进 h 函数阅读 ts 源码（已加上注释）\nSnabbdom 源码阅读h 函数——用于创建虚拟节点export function h(sel: any, b?: any, c?: any): VNode &#123;  let data: VNodeData = &#123;&#125;;  let children: any;  let text: any;  let i: number;  if (c !== undefined) &#123;    /* data就是class等属性 */    if (b !== null) &#123;      data = b;    &#125;    /* 参数c是一个数组，则数组内部每一项都是虚拟DOM对象，都是这个节点的孩子 */    if (is.array(c)) &#123;      children = c;    &#125;    /* 参数c是string或number，则这个节点里的文本内容就是参数c */    else if (is.primitive(c)) &#123;      text = c.toString();    &#125;    /* 根据c的sel属性存在，可以得知参数c也是一个虚拟DOM对象 */    else if (c &amp;&amp; c.sel) &#123;      children = [c];    &#125;  &#125;  /* 只有两个参数，没有c，进行一样的判断 */  else if (b !== undefined &amp;&amp; b !== null) &#123;    if (is.array(b)) &#123;      children = b;    &#125; else if (is.primitive(b)) &#123;      text = b.toString();    &#125; else if (b &amp;&amp; b.sel) &#123;      children = [b];    &#125; else &#123;      data = b;    &#125;  &#125;  if (children !== undefined) &#123;    for (i = 0; i &lt; children.length; ++i) &#123;      /* 如果children中的某一项不是一个对象，只是一个string或number，那么生成一个虚拟DOM包裹这个文本内容 */      if (is.primitive(children[i]))        children[i] = vnode(          undefined, /* sel */          undefined, /* data */          undefined, /* children */          children[i], /* text */          undefined /* elm */        );    &#125;  &#125;  if (    sel[0] === &quot;s&quot; &amp;&amp;    sel[1] === &quot;v&quot; &amp;&amp;    sel[2] === &quot;g&quot; &amp;&amp;    (sel.length === 3 || sel[3] === &quot;.&quot; || sel[3] === &quot;#&quot;)  ) &#123;    addNS(data, children, sel);  &#125;  return vnode(sel, data, children, text, undefined);&#125;\n\n这个函数还是相当好理解的，根据参数的类型和数量，返回一个 VNode 类型的对象（vnode 函数返回 new 出来的），也就是一个虚拟 DOM 节点\nh 函数的返回值——VNode 对象既然 h 函数返回的是一个 VNode 对象，那接下来看看这个类是个什么东西\nexport type Key = string | number | symbol;export interface VNode &#123;  sel: string | undefined;                      // selector，选择器，DOM节点的标签  data: VNodeData | undefined;                  // 节点属性，详细定义见下面VNodeData  children: Array&lt;VNode | string&gt; | undefined;  // 子结点  elm: Node | undefined;                        // 剧透，这个属性是对应的真实DOM节点，undefined表示这个虚拟节点未上树  text: string | undefined;                     // 节点内部  key: Key | undefined;                         // 节点唯一标识，Vue里的key就是这个东西啦&#125;export interface VNodeData &#123;  props?: Props;  attrs?: Attrs;  class?: Classes;  style?: VNodeStyle;  dataset?: Dataset;  on?: On;  attachData?: AttachData;  hook?: Hooks;  key?: Key;  ns?: string; // for SVGs  fn?: () =&gt; VNode; // for thunks  args?: any[]; // for thunks  is?: string; // for custom elements v1  [key: string]: any; // for any other 3rd party module&#125;\n\n这下虚拟 DOM 节点对象的结构就非常清楚了，但还有个小小的问题，props 和 attrs 的区别是什么呢？可以学习这 2 篇博客：\n\nDOM 中 property 和 attribute 详解 1\nDOM 中 property 和 attribute 详解 2\n\n简单的总结一下就是，这两者的区分没有什么规则，但有一定规律，并且 props 是 DOM 元素初始化时自带的一些属性了解清楚创建虚拟 DOM 节点的过程后，下一步开始学习将这个节点渲染到真实 DOM 上的过程\n把虚拟 DOM 节点对象渲染到真实 DOM首先，我们先截取出样例代码的第一个虚拟 DOM，也就是 vnode 的渲染这一块，并且把最外层 h 函数中的 id 改成 outer：\nconst container = document.getElementById(&quot;container&quot;)// 注意这里id换成了outerconst vnode = h(&quot;div#outer.two.classes&quot;, &#123; on: &#123; click: () =&gt; &#123; &#125; &#125; &#125;, [  h(&quot;span&quot;, &#123; style: &#123; fontWeight: &quot;bold&quot; &#125; &#125;, &quot;This is bold&quot;),  &quot; and this is just normal text&quot;,  h(&quot;a&quot;, &#123; props: &#123; href: &quot;/foo&quot; &#125; &#125;, &quot;I&#x27;ll take you places!&quot;),])patch(container, vnode)\n\n如果只运行这部分代码，页面会呈现什么样子呢，下面是页面的效果和 html 结构body 下的 div 的 id 变成了 outer，那 patch 函数的作用就非常明显了，就是替换掉真实 DOM 元素！但这个过程显然不可能是把整个真实的 DOM 节点直接替换，这样开销实在是太大了。因此 patch 函数内部的逻辑必然是只替换内容有改变，或插入新增的 DOM 元素，本文心心念念的第一个 diff 算法就在里面！\n而 patch 函数是通过 init 函数生成的，因此让我们深入到 init 函数中\ninit 函数——返回实现 diff 函数的 patchinit 函数非常长，因此先抛开功能函数，直接关注 init 函数真实执行的部分\nexport function init(  modules: Array&lt;Partial&lt;Module&gt;&gt;,  domApi?: DOMAPI,  options?: Options) &#123;  const cbs: ModuleHooks = &#123;    create: [],    update: [],    remove: [],    destroy: [],    pre: [],    post: [],  &#125;;  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;  // 收集第三方模块提供的各种钩子  for (const hook of hooks) &#123;    for (const module of modules) &#123;      const currentHook = module[hook];      if (currentHook !== undefined) &#123;        (cbs[hook] as any[]).push(currentHook);      &#125;    &#125;  &#125;  // 一些功能函数  return function patch(    oldVnode: VNode | Element | DocumentFragment,    vnode: VNode  ): VNode &#123;    let i: number, elm: Node, parent: Node;    const insertedVnodeQueue: VNodeQueue = [];    // 先执行第三方模块传入的pre钩子    for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]();    // 如果oldVnode是真实DOM，返回一个只有指向真实DOM的指针的虚拟DOM    if (isElement(api, oldVnode)) &#123;      oldVnode = emptyNodeAt(oldVnode);    &#125;    // 同理，判断是否真实DocumentFragmentAt，返回虚拟的vnode对象    else if (isDocumentFragment(api, oldVnode)) &#123;      oldVnode = emptyDocumentFragmentAt(oldVnode);    &#125;    // 判断两个虚拟DOM对象的key、data类型、标签、id、class（标签、id和class都为空时判断内部文本内容类型）是否全都相同    // 是的话可以确定，新旧虚拟DOM指向同一个真实DOM（或者同一个template），需要替换内容    if (sameVnode(oldVnode, vnode)) &#123;      patchVnode(oldVnode, vnode, insertedVnodeQueue);    &#125;    // 否则直接删掉旧虚拟DOM指向的真实DOM，给新的虚拟DOM创建真实DOM，接到父节点上    else &#123;      elm = oldVnode.elm!;      parent = api.parentNode(elm) as Node;      // 这个函数用于递归创建出一整棵以vnode为根的真实DOM树      createElm(vnode, insertedVnodeQueue);      if (parent !== null) &#123;        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));        // 传入虚拟DOM，批量递归删除真实DOM        removeVnodes(parent, [oldVnode], 0, 0);      &#125;    &#125;    // 最后替换完毕后按顺序执行inserted钩子    for (i = 0; i &lt; insertedVnodeQueue.length; ++i) &#123;      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);    &#125;    // 然后执行post钩子    for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i]();    return vnode;  &#125;;&#125;\n\n只看这部分就可以发现，对 patch 函数的执行逻辑影响最大的，是sameVnode(oldVnode, vnode)的判断结果而sameVnode的判断逻辑如注释所说，判断两个虚拟 DOM 对象的 key、data、标签、id、class（标签、id 和 class 都为空时判断内部文本内容类型）是否全都相同也就是说，除非新旧虚拟 DOM 节点的 key、data 类型、标签、id、class 全都一样；或者都没有标签、id、class，但 key、data 类型 一样，且都没有文本内容；否则不会采用 diff 算法，而是直接删掉旧的真实 DOM，生成新的真实 DOM 换上。\n而进入sameVnode(oldVnode, vnode)的判断后，只执行了 patchVnode 这么一个函数，因此继续进入 patchVnode 函数\npatchVnode 函数——替换新旧虚拟 DOM 节点的孩子&#x2F;文本内容先看两个功能函数，addVnodes和removeVnodes这两个功能函数看名字就知道是什么作用：\n\nfunction addVnodes(parentElm: Node,before: Node | null,vnodes: VNode[],startIdx: number,endIdx: number,insertedVnodeQueue: VNodeQueue)在 parentElm 内部，before 的前面批量插入 vnodes 数组从 startIdx 到 endIdx 的节点（创建真实 DOM 插入 parentElm 内）\nfunction removeVnodes(parentElm: Node,vnodes: VNode[],startIdx: number,endIdx: number)在真实 DOM 上的 parentElm 中，删掉 vnodes 数组[startIdx, endIdx]范围内的节点\n\n这两个功能函数由于要执行第三方模块传入的钩子，以及 vnode 本身存在 data 中的钩子，因此还是比较复杂的，但不影响主线逻辑，因此不在这里展开。有兴趣还是建议阅读一下源码，尤其是removeVnodes，通过设置计数器，每次执行 destroy 钩子调用回调函数使计数器减一，确保执行完所有 destroy 钩子后，计数器为 0 时，才真正移除真实 DOM ，这里的设计非常有意思\n/**   *   * @param oldVnode 旧的虚拟DOM节点对象   * @param vnode 新的虚拟DOM节点对象   * @param insertedVnodeQueue 为inserted钩子准备的队列   * @description 完成新旧虚拟DOM中孩子/文本内容的替换   */  function patchVnode(    oldVnode: VNode,    vnode: VNode,    insertedVnodeQueue: VNodeQueue  ) &#123;    // 被替换前先执行prepatch钩子    const hook = vnode.data?.hook;    hook?.prepatch?.(oldVnode, vnode);    const elm = (vnode.elm = oldVnode.elm)!;    // 两个vnode虚拟DOM对象地址都一样，那就不用替换了    if (oldVnode === vnode) return;    // 只要新的vnode存在data，或者新旧vnode的文本内容不一样，就要执行update钩子，第三方模块和vnode自己的都要    if (vnode.data !== undefined || (isDef(vnode.text) &amp;&amp; vnode.text !== oldVnode.text)) &#123;      vnode.data ??= &#123;&#125;;      oldVnode.data ??= &#123;&#125;;      for (let i = 0; i &lt; cbs.update.length; ++i)        cbs.update[i](oldVnode, vnode);      vnode.data?.hook?.update?.(oldVnode, vnode);    &#125;    // 找到新旧vnode的children（都是vnode，也就是虚拟DOM对象）    const oldCh = oldVnode.children as VNode[];    const ch = vnode.children as VNode[];    // 如果新的vnode没有文本内容    if (isUndef(vnode.text)) &#123;      // 新的vnode和旧的vnode都有孩子      // TODO 先放着，待会再看      if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);      &#125;      // 只有新的vnode有孩子，这好办，清空这个真实DOM的文本内容，把新vnode下的孩子都转成真实DOM插入到这个节点就好了      else if (isDef(ch)) &#123;        if (isDef(oldVnode.text)) api.setTextContent(elm, &quot;&quot;);        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);      &#125;      // 只有旧节点有孩子，新节点没有，也好办，直接删光真实DOM节点下的所有孩子就好（如果旧节点有孩子，说明没有文本内容，不用考虑TextContent）      else if (isDef(oldCh)) &#123;        removeVnodes(elm, oldCh, 0, oldCh.length - 1);      &#125;      // 新旧节点都没有孩子，而且新节点也没有文本内容，那要做的变化就是把旧节点的文本内容清空      else if (isDef(oldVnode.text)) &#123;        api.setTextContent(elm, &quot;&quot;);      &#125;    &#125;    // 新vnode有文本内容，旧的vnode不知道有没有，但不全等（隐藏条件是，新vnode没有孩子）    else if (oldVnode.text !== vnode.text) &#123;      // 旧vnode有孩子，但新vnode没有，和上面一样，直接删光真实DOM节点下的所有孩子就好      if (isDef(oldCh)) &#123;        removeVnodes(elm, oldCh, 0, oldCh.length - 1);      &#125;      // 设置文本内容      api.setTextContent(elm, vnode.text!);    &#125;    // 如果上面的判断都没进入，说明新旧节点都由文本内容（也就是都没有孩子），文本内容还完全一样    // 比对完新旧节点，两个虚拟DOM的孩子或文本内容已经换成新的虚拟DOM了    hook?.postpatch?.(oldVnode, vnode);  &#125;\n\n这个函数也是看起来长，实际上逻辑很好理解：\n\n如果新的 vnode 有文本内容，那最简单，把旧 vnode 指向的真实 DOM 的孩子清空（如果有的话），然后文本内容换成新 vnode 的内容就好了\n如果新 vnode 没有文本内容，那进一步分情况讨论\n如果新 vnode 没有孩子，旧 vnode 也没有，那把真实 DOM 的文本内容清空\n如果新 vnode 没有孩子，旧 vnode 有，把这个真实 DOM 下的孩子节点都删空（也就是 oldVnode 的 children 指向的真实 DOM）\n如果新 vnode 有孩子，旧 vnode 没有，清空真实 DOM 的文本内容，然后为新 vnode 的孩子们创建真实 DOM，插入到新旧 vnode 共同指向的真实 DOM 中\n如果新 vnode 有孩子，旧 vnode 也有，最麻烦的情况，调用了updateChildren函数处理（先经过新 vnode 与旧 vnode 的孩子数组地址是否一样的判断，孩子数组的地址都一样那就不需要更新孩子了）\n\n\n\n理清楚这个判断逻辑后，真正需要耗费脑力的，就是这个updateChildren函数了。\n但先不急着进入这个函数，先考虑一个小问题：patchVnode 函数执行完，就意味着 patch 函数的主要逻辑已经结束了，只剩下 inserted 和 post 钩子的执行，那 data 是在哪里更新的呢？？ 难道说就是在updateChildren函数里，只要不调用 updateChildren，data 就不会更新？下面先验证一下这个猜想\n寻找 vnode 的 data 的更新位置根据上面的分析，我们知道，如果 patch 的第一个参数是一个真实 dom，只要第二个参数传入的虚拟 DOM vnode 的标签、selector 都和第一个参数一样，并且 data 不为空（可以是空对象，data 这个属性不是 null 或 undefine 就好了），patch就会调用patchVnode（如果不调用patchVnode，我们传入的新 vnode 会直接生成一个新的真实 DOM，data 就不算更新，而是删光原来的再新建一个）。因此修改一下我们的 index.js，让 vnode 的 selector 与真实 DOM div 保持一致，然后给个新的 data（这里用 props 中的 href）：\n&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;你好&lt;/div&gt;  &lt;script src=&quot;/fake/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;\n\nconst container = document.getElementById(&quot;container&quot;)const vnode = h(&quot;div#container&quot;, &#123; props: &#123; href: &#x27;123&#x27; &#125; &#125;, &#x27;哈哈&#x27;)patch(container, vnode)\n\n然后修改一下 snabbdom 源码（build 里的 js 文件，ts 只是阅读的，js 才是实际调用的）然后运行 dev server，观察输出结果：这下结果就很明显了，data 的更新位置在第三方模块传入的 update 钩子中！\n既然是第三方传入的，那不急着看传入的 update 钩子函数的内容；但我们得到了一个结论，patchVnode函数看起来只更新孩子节点或文本内容，是因为在开头的钩子函数中已经处理 data 的更新。接下来就进入updateChildren函数，观察两个 vnode 都有孩子的情况下，真实 DOM 是怎么更新的\nupdateChildren 函数——新旧 vnode 都有孩子的情况下更新真实 DOM为了更好的理解这个函数，我们把 sameVnode 的作用换一个更合适的说法：如果 sameVnode 的判断为真，就说明 oldVnode 指向的真实 DOM 不需要销毁，只需要改变内容，或者改变位置就可以了\n这个想法非常关键，因为 diff 的最小更新思路，就是通过尽量不删除真实 DOM实现的。\n既然要真实 DOM 尽可能少销毁，那么平时在使用框架开发时，我们经常对表格的数据进行排序，这一过程就必然只涉及真实 DOM 节点的移动。而真实 DOM 节点的移动通过下面这个 DOM api 实现：这个函数接收两个真实 DOM 元素作为参数，调用的节点为父元素，第二个参数是这个父元素的孩子，函数的作用是把第一个参数的节点插入这个父元素中，并插入在第二个参数传入的孩子前，。但值得注意的是，选中的部分已经说明了，如果第一个参数已经存在父节点中，那么第一个参数传入的节点只会移动位置，而不会新建一个一样的节点。这就实现了我们需要的移动效果。\n接下来，真正开始看这最核心部分的源码，思路过程都在注释里\nfunction updateChildren(    parentElm: Node,    oldCh: VNode[],    newCh: VNode[],    insertedVnodeQueue: VNodeQueue  ) &#123;    // 这些指针都是指向当前未处理的节点！！    let oldStartIdx = 0;    let newStartIdx = 0;    let oldEndIdx = oldCh.length - 1;    let oldStartVnode = oldCh[0];    let oldEndVnode = oldCh[oldEndIdx];    let newEndIdx = newCh.length - 1;    let newStartVnode = newCh[0];    let newEndVnode = newCh[newEndIdx];    let oldKeyToIdx: KeyToIndexMap | undefined;    let idxInOld: number;    let elmToMove: VNode;    let before: any;    // 下面的循环体中的内容，实质上是找到所有可以复用的真实DOM节点（我们的目的就是尽可能复用，少删除少新建），更新他们的内容并插到合适的位置    // 如果旧的vnode的待处理节点指针相遇，说明现有的真实DOM已经处理完了，如果新的vnode指针还没相遇，剩下的孩子就都是必须新建真实DOM的了    // 如果新的vnode的待处理节点指针相遇，说明真实DOM的两侧已经是我们期待的样子了，中间的真实DOM也就是旧vnode待处理指针之间的，都是必须得删除的    // 上述两种情况，都是说明现有的可以复用的真实DOM已经更新复用完了，剩下多出来的必须要删除，缺少的就必须要新建    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;      // 注意，这里用的不是===，而undefine == null是true      if (oldStartVnode == null) &#123;        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left      &#125; else if (oldEndVnode == null) &#123;        oldEndVnode = oldCh[--oldEndIdx];      &#125; else if (newStartVnode == null) &#123;        newStartVnode = newCh[++newStartIdx];      &#125; else if (newEndVnode == null) &#123;        newEndVnode = newCh[--newEndIdx];      &#125;      // 下面开始处理，首先我们最希望的的肯定是真实DOM不用删除，也不用移动，就在当前位置更新就好      // 所以先看看左侧第一个真实DOM要不要删除或移动      else if (sameVnode(oldStartVnode, newStartVnode)) &#123;        // 左侧第一个真实DOM可以被复用！那么原地更新就好，当前节点处理完，左侧的待处理指针右移        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);        oldStartVnode = oldCh[++oldStartIdx];        newStartVnode = newCh[++newStartIdx];      &#125;      // 很遗憾左侧第一个的真实DOM和新的虚拟DOM对不上，也就是说可能要被移动到其他地方或者被删除      // 那我们再从右侧判断，看看右侧第一个真实DOM要不要删除或移动      else if (sameVnode(oldEndVnode, newEndVnode)) &#123;        // 右侧第一个真实DOM可以被复用！那么原地更新就好，当前节点处理完，右侧的待处理指针左移        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);        oldEndVnode = oldCh[--oldEndIdx];        newEndVnode = newCh[--newEndIdx];      &#125;      // 没办法，左右两侧的真实DOM都和我们期待的样子对不上      // 但还可能存在一种情况：      // 初始状态 A B C ...... X Y Z      // 目标状态 A B U ...... C Y Z      // 经过刚刚的两种最简单的判断，左侧的A B和右侧的Y Z都已经更新完      // 所以oldStartVnode指向C，oldEndVnode指向X，newStartVnode指向U，newEndVnode指向C      // 我们一眼就能看出来C只用换个位置，C插在oldEndVnode的后一项的前面（把X往前挤）就好了      // 下面的代码就是干这件事，看看有没有现在最左侧的真实DOM是可以直接移到右侧的      // 尽可能少循环，不考虑真实DOM的移动过程的话，这种判断的时间复杂度就是O(1)，      else if (sameVnode(oldStartVnode, newEndVnode)) &#123;        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);        // 移动到oldEndVnode的后一项的前面        api.insertBefore(          parentElm,          oldStartVnode.elm!,          api.nextSibling(oldEndVnode.elm!)        );        // 待处理的指针移动        oldStartVnode = oldCh[++oldStartIdx];        newEndVnode = newCh[--newEndIdx];      &#125;      // 同理，和上面的不同方向罢了      else if (sameVnode(oldEndVnode, newStartVnode)) &#123;        // Vnode moved left        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);        oldEndVnode = oldCh[--oldEndIdx];        newStartVnode = newCh[++newStartIdx];      &#125;      // 没办法了，当前真实DOM两端的节点都找不到能复用的位置      // 此时待处理指针两侧的真实DOM已经更新，排列成我们希望的样子了（和新的虚拟DOM一样）      // 那我们从新虚拟DOM待处理的最左侧节点入手，去循环找有没有 未被复用过，但现在可以拿来复用的真实DOM      // 如果有，拿来更新内容，插在oldStartVnode指向的真实DOM的前面就好了（因为新的虚拟DOM期待它在当前未处理的最左侧）      // 记得把被复用的这个真实DOM对应的oldVnode标记为已经复用过，设置成undefine就好了，经过上面undefnie == null的判断会被过滤掉      // 如果没有可以复用的真实DOM，只好新建了，还是插在oldStartVnode指向的真实DOM的前面      else &#123;        // 这里判断是否可以复用，只与key、孩子的标签有关，都相同就可以复用        if (oldKeyToIdx === undefined) &#123;          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);        &#125;        idxInOld = oldKeyToIdx[newStartVnode.key as string];        // 没找到真实DOM中有相同的key，那没办法，新建吧        if (isUndef(idxInOld)) &#123;          // New element          api.insertBefore(            parentElm,            createElm(newStartVnode, insertedVnodeQueue),            oldStartVnode.elm!          );        &#125;        // 有相同的key        else &#123;          elmToMove = oldCh[idxInOld];          // 也要判断一下标签，标签相同才能复用真实DOM          if (elmToMove.sel !== newStartVnode.sel) &#123;            api.insertBefore(              parentElm,              createElm(newStartVnode, insertedVnodeQueue),              oldStartVnode.elm!            );          &#125;          // 终于可以复用了          else &#123;            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);            // 真实DOM已经更新而且移动完了，那么对应的这个旧虚拟DOM应当被标记成处理完            oldCh[idxInOld] = undefined as any;            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);          &#125;        &#125;        newStartVnode = newCh[++newStartIdx];      &#125;    &#125;    // 跳出循环咯，下面就是不得不新建的，或者是不得不删除的    if (newStartIdx &lt;= newEndIdx) &#123;      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;      addVnodes(        parentElm,        before,        newCh,        newStartIdx,        newEndIdx,        insertedVnodeQueue      );    &#125;    if (oldStartIdx &lt;= oldEndIdx) &#123;      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);    &#125;    // 真实DOM更新完毕  &#125;\n\n看起来很复杂，但简单说就是双指针往中间扫描，尽可能不用移动真实 DOM；即使要移动，也尽可能不要循环，直接首尾两端交换；最后才不得不循环找能复用的真实 DOM。这个函数走完，真实 DOM 就变成和新虚拟 DOM 一样的结构了，内容也都更新完毕，Snabbdom diff 算法完结撒花\nSnabbdom 完整源码带注释Snabbdom 完整源码带注释\n虚拟 DOM 的优缺点优点\n保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；\n无需手动操作 DOM： 不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，以可预期的方式更新视图，极大提高开发效率；\n跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。\n\n缺点\n无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化；\n首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。\n\n","categories":["学习"],"tags":["前端"]},{"title":"webpack简易笔记","url":"/2023/03/13/webpack%E5%AD%A6%E4%B9%A0/","content":"持续更新中不得不说上班摸鱼是一件快乐的事情\n开始众所周知，vue-cli 和 create-react-app 都是内置 webpack 进行打包那么这个这么重要的东西是什么，官网是这样定义的\n\nwebpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles[^1]，它们均为静态资源，用于展示你的内容。\n\n（好的，看到官网这种不说人话的风格是真的发晕，也就贴上来镇场子）\n[^1]: bundles 是 webpack 打包后生成的文件，它们包含了经过加载和编译的源代码。一个 bundle 可以由一个或多个模块（module）组成，模块是 webpack 处理项目中的不同类型的文件的基本单位。\n为什么使用 webpack首先，模块化开发是历史的趋势，不解释那模块化开发，总得引入模块呀，所以随着不同模块化规范的出现，引入模块的语法也出现了好几种，最常见的两个：\n// CommonJSconst path = require(&#x27;path&#x27;)// ES6import Vue from &#x27;vue&#x27;\n\n那分成了不同模块，运行代码的时候得有人做类似编译链接的事情呀，不然鬼知道依赖树有多高有多大所以构建工具就成了必不可少的了，webpack 就是其中之一加上对于模块化开发来说有个坏消息，就是上面这些引入模块的语法刚面世的时候浏览器不双标，几乎一视同仁的不支持所以构建工具还得肩负起把这些高级语法转换成 ES5 语法，这才能让浏览器执行。\n入门稍微详细点说，webpac 打包的时候做了这些事:\n\n解析入口文件\n递归分析依赖，生成抽象语法树\n根据入口和依赖模块生成 chunk（有点类似手动的分包，打包完后这些 chunk 是可以按需下载，也可以并行下载加快加载速度）\n把每个模块进行转换，这里的模块除了 js 还包含 css、图片等等，但 webpack 本身是只认识 js 和 json 的，所以在这一步中,webpack 会按顺序链式调用所有配置好的 Loader 对模块进行处理。此外这一步还包括把 js 转译成 ES5 语法，对代码进行压缩等等\n对每个 chunk 进行优化、整合、拆分、去重等操作，生成最终的资源文件（assets）\n输出资源文件到指定的目录中\n\n然后就得到熟悉的 dist 目录啦但是为什么上面的全是抽象的名词捏，还是需要更详细点的过程解析（晕）\n","categories":["学习"],"tags":["前端"]},{"title":"vite模块化加载store和接口","url":"/2023/03/11/vite%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDstore%E5%92%8C%E6%8E%A5%E5%8F%A3/","content":"问题描述在过去的实习和项目开发经历中，规范的大项目都是使用 vue2，因此习惯了使用 webpack 的 require.context 批量导入模块。但最近学习使用 vite + taildwindcss 进行开发时想起来 vite 没有这个接口，因此找办法代替\n目录结构\nwebpack 写法// index.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)Vue.config.devtools = true; // 打开vue调试工具const files = require.context(&#x27;./modules&#x27;, false, /\\.js$/)const modules = &#123;&#125;files.keys().forEach((key) =&gt; &#123;  modules[key.replace(/(\\.\\/|\\.js)/g, &#x27;&#x27;)] = files(key).default&#125;)Object.keys(modules).forEach((key) =&gt; &#123;  modules[key][&#x27;namespaced&#x27;] = true&#125;)const store = new Vuex.Store(&#123;  modules&#125;)export default store\n\nvite 写法// index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;const routeFiles = import.meta.globEager(&#x27;@/store/modules/*.js&#x27;)const modules = &#123;&#125;for (const path in routeFiles) &#123;  const key = path.match(/\\/src\\/store\\/modules\\/(.*?).js/)[1]  modules[key] = routeFiles[path].default  modules[key][&#x27;namespaced&#x27;] = true&#125;export default createStore(&#123;  modules&#125;)\n\n问题解决\n","categories":["学习"],"tags":["前端"]},{"title":"Springboot实现数据库读写分离","url":"/2023/03/11/Springboot%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/","content":"前言由于 shardingsphere 官方文档的配置参考用了报错，网上的也基本用不了，于是参考其他博客，通过 aop 手动更改数据源。\n参考博客第一篇第二篇前置操作：配置好 mysql 的读写分离\nSpringboot yml 配置文件(部分)spring:  datasource:    master:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 主数据库链接      username: 用户      password: 密码    slave0:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 从数据库链接      username: 用户      password: 密码    其他从数据库: ...\n\n配置了多个数据源，因此需要一个配置类，设置当前使用哪个数据源。\n枚举类先创建一个枚举类，作为数据源的 key\npublic enum DBTypeEnum &#123;    MASTER, SLAVE0;&#125;\n\n数据源配置类@Configurationpublic class DataSourceConfig &#123;    @Bean    @ConfigurationProperties(&quot;spring.datasource.master&quot;)    public DataSource masterDataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    @ConfigurationProperties(&quot;spring.datasource.slave0&quot;)    public DataSource slave0DataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    public DataSource myRoutingDataSource(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource,                                          @Qualifier(&quot;slave0DataSource&quot;) DataSource slave0DataSource) &#123;        // 把所有数据源放入map中待更换        HashMap&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();        targetDataSources.put(DBTypeEnum.MASTER, masterDataSource);        targetDataSources.put(DBTypeEnum.SLAVE0, slave0DataSource);        MyRoutingDataSource myRoutingDataSource = new MyRoutingDataSource();        // 设置默认数据源        myRoutingDataSource.setDefaultTargetDataSource(masterDataSource);        myRoutingDataSource.setTargetDataSources(targetDataSources);        return myRoutingDataSource;    &#125;&#125;\n\nmybatis 配置类配置 mybatis，使用 myRoutingDataSource 这个数据源\n@EnableTransactionManagement(order = 10) // 设置事务优先级，这很重要！！@Configurationpublic class MyBatisConfig &#123;    @Resource(name = &quot;myRoutingDataSource&quot;)    private DataSource myRoutingDataSource;    @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception &#123;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(myRoutingDataSource);        return sqlSessionFactoryBean.getObject();    &#125;    @Bean    public PlatformTransactionManager platformTransactionManager() &#123;        return new DataSourceTransactionManager(myRoutingDataSource);    &#125;&#125;\n\n把数据源配置到线程上下文中public class DBContextHolder &#123;    private static final ThreadLocal&lt;DBTypeEnum&gt; contextHolder = new ThreadLocal&lt;&gt;();    public static DBTypeEnum get() &#123;        if (contextHolder.get() == null)            contextHolder.set(DBTypeEnum.MASTER);        return contextHolder.get();    &#125;    public static void master() &#123;        contextHolder.set(DBTypeEnum.MASTER);        System.out.println(&quot;切换到master&quot;);    &#125;    public static void slave() &#123;        contextHolder.set(DBTypeEnum.SLAVE0);    &#125;&#125;\n\n重写 determineCurrentLookupKey 切换数据源public class MyRoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        return DBContextHolder.get();    &#125;&#125;\n\nAOP最后，通过 aop，在每次执行 mybatis 的前判断 sql 类型，读操作分配从数据库，写操作分配到主数据库。根据参考博客，有可能存在必须从主库读的情况，因此加一个注解表示强制从主库读：\n@Aspect@Componentpublic class DataSourceAop implements Ordered &#123;    @Pointcut(&quot;!@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.get*(..)))&quot;)    public void readPointcut() &#123;    &#125;    @Pointcut(&quot;@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.create*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.update*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.delete*(..)) &quot;)    public void writePointcut() &#123;    &#125;    @Before(&quot;readPointcut()&quot;)    public void read() &#123;        DBContextHolder.slave();    &#125;    @Before(&quot;writePointcut()&quot;)    public void write() &#123;        DBContextHolder.master();    &#125;    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;\n\n注意这里重写了 getOrder 方法，这是因为按照第一篇博客的配置，会发现服务器的执行顺序是 springboot 拿到数据源-&gt;尝试执行 sql-&gt;aop-&gt;执行 sql，这样一来 aop 改变数据源就没有效果，全是从主机读写。因此需要把数据库事务的优先级调低，把 aop 操作的优先级调高，确保数据源被成功切换。可以通过数据库通用查询日志（general_log）观察读写分离是否成功。\n","categories":["学习"],"tags":["后端","数据库"]},{"title":"Hello World","url":"/2023/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["其他"],"tags":["其他"]}]