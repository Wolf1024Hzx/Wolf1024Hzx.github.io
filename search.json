[{"title":"webpack简易笔记","url":"/2023/03/13/webpack%E5%AD%A6%E4%B9%A0/","content":"持续更新中不得不说上班摸鱼是一件快乐的事情\n开始众所周知，vue-cli和create-react-app都是内置webpack进行打包那么这个这么重要的东西是什么，官网是这样定义的\n\nwebpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles^1，它们均为静态资源，用于展示你的内容。\n\n（好的，看到官网这种不说人话的风格是真的发晕，也就贴上来镇场子）\n为什么使用webpack首先，模块化开发是历史的趋势，不解释那模块化开发，总得引入模块呀，所以随着不同模块化规范的出现，引入模块的语法也出现了好几种，最常见的两个：\n// CommonJSconst path = require(&#x27;path&#x27;)// ES6import Vue from &#x27;vue&#x27;\n那分成了不同模块，运行代码的时候得有人做类似编译链接的事情呀，不然鬼知道依赖树有多高有多大所以构建工具就成了必不可少的了，webpack就是其中之一加上对于模块化开发来说有个坏消息，就是上面这些引入模块的语法刚面世的时候浏览器不双标，几乎一视同仁的不支持所以构建工具还得肩负起把这些高级语法转换成ES5语法，这才能让浏览器执行。\n入门稍微详细点说，webpac打包的时候做了这些事:\n\n解析入口文件\n递归分析依赖，生成抽象语法树\n根据入口和依赖模块生成 chunk（有点类似手动的分包，打包完后这些chunk是可以按需下载，也可以并行下载加快加载速度）\n把每个模块进行转换，这里的模块除了js还包含css、图片等等，但webpack本身是只认识js和json的，所以在这一步中,webpack会按顺序链式调用所有配置好的Loader对模块进行处理。此外这一步还包括把js转译成ES5语法，对代码进行压缩等等\n对每个 chunk 进行优化、整合、拆分、去重等操作，生成最终的资源文件（assets）\n输出资源文件到指定的目录中\n\n然后就得到熟悉的dist目录啦但是为什么上面的全是抽象的名词捏，还是需要更详细点的过程解析（晕）\n","categories":["学习"],"tags":["前端"]},{"title":"vite模块化加载store和接口","url":"/2023/03/11/vite%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BDstore%E5%92%8C%E6%8E%A5%E5%8F%A3/","content":"问题描述在过去的实习和项目开发经历中，规范的大项目都是使用vue2，因此习惯了使用webpack的require.context批量导入模块。但最近学习使用vite + taildwindcss进行开发时想起来vite没有这个接口，因此找办法代替\n目录结构\nwebpack写法// index.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)Vue.config.devtools = true; // 打开vue调试工具const files = require.context(&#x27;./modules&#x27;, false, /\\.js$/)const modules = &#123;&#125;files.keys().forEach((key) =&gt; &#123;  modules[key.replace(/(\\.\\/|\\.js)/g, &#x27;&#x27;)] = files(key).default&#125;)Object.keys(modules).forEach((key) =&gt; &#123;  modules[key][&#x27;namespaced&#x27;] = true&#125;)const store = new Vuex.Store(&#123;  modules&#125;)export default store\nvite写法// index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;const routeFiles = import.meta.globEager(&#x27;@/store/modules/*.js&#x27;)const modules = &#123;&#125;for (const path in routeFiles) &#123;  const key = path.match(/\\/src\\/store\\/modules\\/(.*?).js/)[1]  modules[key] = routeFiles[path].default  modules[key][&#x27;namespaced&#x27;] = true&#125;export default createStore(&#123;  modules&#125;)\n问题解决\n","categories":["学习"],"tags":["前端"]},{"title":"Springboot实现数据库读写分离","url":"/2023/03/11/Springboot%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/","content":"前言由于shardingsphere官方文档的配置参考用了报错，网上的也基本用不了，于是参考其他博客，通过aop手动更改数据源。\n参考博客第一篇第二篇前置操作：配置好mysql的读写分离\nSpringboot yml配置文件(部分)spring:  datasource:    master:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 主数据库链接      username: 用户      password: 密码    slave0:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 从数据库链接      username: 用户      password: 密码    其他从数据库:      ...\n配置了多个数据源，因此需要一个配置类，设置当前使用哪个数据源。\n枚举类先创建一个枚举类，作为数据源的key\npublic enum DBTypeEnum &#123;    MASTER, SLAVE0;&#125;\n数据源配置类@Configurationpublic class DataSourceConfig &#123;    @Bean    @ConfigurationProperties(&quot;spring.datasource.master&quot;)    public DataSource masterDataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    @ConfigurationProperties(&quot;spring.datasource.slave0&quot;)    public DataSource slave0DataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    public DataSource myRoutingDataSource(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource,                                          @Qualifier(&quot;slave0DataSource&quot;) DataSource slave0DataSource) &#123;        // 把所有数据源放入map中待更换        HashMap&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();        targetDataSources.put(DBTypeEnum.MASTER, masterDataSource);        targetDataSources.put(DBTypeEnum.SLAVE0, slave0DataSource);        MyRoutingDataSource myRoutingDataSource = new MyRoutingDataSource();        // 设置默认数据源        myRoutingDataSource.setDefaultTargetDataSource(masterDataSource);        myRoutingDataSource.setTargetDataSources(targetDataSources);        return myRoutingDataSource;    &#125;&#125;\nmybatis配置类配置mybatis，使用myRoutingDataSource这个数据源\n@EnableTransactionManagement(order = 10) // 设置事务优先级，这很重要！！@Configurationpublic class MyBatisConfig &#123;    @Resource(name = &quot;myRoutingDataSource&quot;)    private DataSource myRoutingDataSource;    @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception &#123;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(myRoutingDataSource);        return sqlSessionFactoryBean.getObject();    &#125;    @Bean    public PlatformTransactionManager platformTransactionManager() &#123;        return new DataSourceTransactionManager(myRoutingDataSource);    &#125;&#125;\n把数据源配置到线程上下文中public class DBContextHolder &#123;    private static final ThreadLocal&lt;DBTypeEnum&gt; contextHolder = new ThreadLocal&lt;&gt;();    public static DBTypeEnum get() &#123;        if (contextHolder.get() == null)            contextHolder.set(DBTypeEnum.MASTER);        return contextHolder.get();    &#125;    public static void master() &#123;        contextHolder.set(DBTypeEnum.MASTER);        System.out.println(&quot;切换到master&quot;);    &#125;    public static void slave() &#123;        contextHolder.set(DBTypeEnum.SLAVE0);    &#125;&#125;\n重写determineCurrentLookupKey切换数据源public class MyRoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        return DBContextHolder.get();    &#125;&#125;\nAOP最后，通过aop，在每次执行mybatis的前判断sql类型，读操作分配从数据库，写操作分配到主数据库。根据参考博客，有可能存在必须从主库读的情况，因此加一个注解表示强制从主库读：\n@Aspect@Componentpublic class DataSourceAop implements Ordered &#123;    @Pointcut(&quot;!@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.get*(..)))&quot;)    public void readPointcut() &#123;    &#125;    @Pointcut(&quot;@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.create*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.update*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.delete*(..)) &quot;)    public void writePointcut() &#123;    &#125;    @Before(&quot;readPointcut()&quot;)    public void read() &#123;        DBContextHolder.slave();    &#125;    @Before(&quot;writePointcut()&quot;)    public void write() &#123;        DBContextHolder.master();    &#125;    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;\n注意这里重写了getOrder方法，这是因为按照第一篇博客的配置，会发现服务器的执行顺序是springboot拿到数据源-&gt;尝试执行sql-&gt;aop-&gt;执行sql，这样一来aop改变数据源就没有效果，全是从主机读写。因此需要把数据库事务的优先级调低，把aop操作的优先级调高，确保数据源被成功切换。可以通过数据库通用查询日志（general_log）观察读写分离是否成功。\n","categories":["学习"],"tags":["后端","数据库"]},{"title":"Hello World","url":"/2023/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["其他"],"tags":["其他"]}]