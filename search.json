[{"title":"Springboot实现数据库读写分离","url":"/2023/03/11/Springboot%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/","content":"前言由于shardingsphere官方文档的配置参考用了报错，网上的也基本用不了，于是参考其他博客，通过aop手动更改数据源。\n参考博客第一篇第二篇前置操作：配置好mysql的读写分离\nSpringboot yml配置文件(部分)spring:  datasource:    master:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 主数据库链接      username: 用户      password: 密码    slave0:      driver-class-name: com.mysql.cj.jdbc.Driver      jdbc-url: 从数据库链接      username: 用户      password: 密码    其他从数据库:      ...\n配置了多个数据源，因此需要一个配置类，设置当前使用哪个数据源。\n枚举类先创建一个枚举类，作为数据源的key\npublic enum DBTypeEnum &#123;    MASTER, SLAVE0;&#125;\n数据源配置类@Configurationpublic class DataSourceConfig &#123;    @Bean    @ConfigurationProperties(&quot;spring.datasource.master&quot;)    public DataSource masterDataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    @ConfigurationProperties(&quot;spring.datasource.slave0&quot;)    public DataSource slave0DataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    @Bean    public DataSource myRoutingDataSource(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource,                                          @Qualifier(&quot;slave0DataSource&quot;) DataSource slave0DataSource) &#123;        // 把所有数据源放入map中待更换        HashMap&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();        targetDataSources.put(DBTypeEnum.MASTER, masterDataSource);        targetDataSources.put(DBTypeEnum.SLAVE0, slave0DataSource);        MyRoutingDataSource myRoutingDataSource = new MyRoutingDataSource();        // 设置默认数据源        myRoutingDataSource.setDefaultTargetDataSource(masterDataSource);        myRoutingDataSource.setTargetDataSources(targetDataSources);        return myRoutingDataSource;    &#125;&#125;\nmybatis配置类配置mybatis，使用myRoutingDataSource这个数据源\n@EnableTransactionManagement(order = 10) // 设置事务优先级，这很重要！！@Configurationpublic class MyBatisConfig &#123;    @Resource(name = &quot;myRoutingDataSource&quot;)    private DataSource myRoutingDataSource;    @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception &#123;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(myRoutingDataSource);        return sqlSessionFactoryBean.getObject();    &#125;    @Bean    public PlatformTransactionManager platformTransactionManager() &#123;        return new DataSourceTransactionManager(myRoutingDataSource);    &#125;&#125;\n把数据源配置到线程上下文中public class DBContextHolder &#123;    private static final ThreadLocal&lt;DBTypeEnum&gt; contextHolder = new ThreadLocal&lt;&gt;();    public static DBTypeEnum get() &#123;        if (contextHolder.get() == null)            contextHolder.set(DBTypeEnum.MASTER);        return contextHolder.get();    &#125;    public static void master() &#123;        contextHolder.set(DBTypeEnum.MASTER);        System.out.println(&quot;切换到master&quot;);    &#125;    public static void slave() &#123;        contextHolder.set(DBTypeEnum.SLAVE0);    &#125;&#125;\n重写determineCurrentLookupKey切换数据源public class MyRoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        return DBContextHolder.get();    &#125;&#125;\nAOP最后，通过aop，在每次执行mybatis的前判断sql类型，读操作分配从数据库，写操作分配到主数据库。根据参考博客，有可能存在必须从主库读的情况，因此加一个注解表示强制从主库读：\n@Aspect@Componentpublic class DataSourceAop implements Ordered &#123;    @Pointcut(&quot;!@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.get*(..)))&quot;)    public void readPointcut() &#123;    &#125;    @Pointcut(&quot;@annotation(com.wolf1024hzx.annotation.Master) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.create*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.update*(..)) &quot; +            &quot;|| execution(* com.wolf1024hzx.service..*.delete*(..)) &quot;)    public void writePointcut() &#123;    &#125;    @Before(&quot;readPointcut()&quot;)    public void read() &#123;        DBContextHolder.slave();    &#125;    @Before(&quot;writePointcut()&quot;)    public void write() &#123;        DBContextHolder.master();    &#125;    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;\n注意这里重写了getOrder方法，这是因为按照第一篇博客的配置，会发现服务器的执行顺序是springboot拿到数据源-&gt;尝试执行sql-&gt;aop-&gt;执行sql，这样一来aop改变数据源就没有效果，全是从主机读写。因此需要把数据库事务的优先级调低，把aop操作的优先级调高，确保数据源被成功切换。可以通过数据库通用查询日志（general_log）观察读写分离是否成功。\n","categories":["学习"],"tags":["后端","数据库"]},{"title":"Hello World","url":"/2023/03/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["其他"],"tags":["其他"]}]